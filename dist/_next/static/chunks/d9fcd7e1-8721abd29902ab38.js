"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[792],{2325:function(a,b,c){var d=c(8764).Buffer,e=c(2223),f=c(496),g=c(7060),h=(c(7503),c(2474)),i=c(2297),j=c(5131),k=c(4285),l=c(7083),m=c(1094);function n(a){return a&&"object"==typeof a&&"default"in a?a:{default:a}}function o(a){if(a&&a.__esModule)return a;var b=Object.create(null);return a&&Object.keys(a).forEach(function(c){if("default"!==c){var d=Object.getOwnPropertyDescriptor(a,c);Object.defineProperty(b,c,d.get?d:{enumerable:!0,get:function(){return a[c]}})}}),b.default=a,Object.freeze(b)}var p=o(e),q=n(g),r=n(h),s=o(i),t=n(l),u=n(m);f.Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),f.Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");let v=f.Scalar.e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab",16),w=f.Scalar.e("21888242871839275222246405745257275088696311157297823662689037894645226208583");async function x(a){let b;if(f.Scalar.eq(a,w))b=await f.buildBn128();else if(f.Scalar.eq(a,v))b=await f.buildBls12381();else throw Error(`Curve not supported: ${f.Scalar.toString(a)}`);return b}async function y(a){var b;let c,d=(b=a,b.toUpperCase().match(/[A-Za-z0-9]+/g).join(""));if(["BN128","BN254","ALTBN128"].indexOf(d)>=0)c=await f.buildBn128();else if(["BLS12381"].indexOf(d)>=0)c=await f.buildBls12381();else throw Error(`Curve not supported: ${a}`);return c}function z(a){return((4294901760&a)!=0?(a&=4294901760,16):0)|((4278255360&a)!=0?(a&=4278255360,8):0)|((4042322160&a)!=0?(a&=4042322160,4):0)|((3435973836&a)!=0?(a&=3435973836,2):0)|(2863311530&a)!=0}function A(a,b){let c=new DataView(a.buffer,a.byteOffset,a.byteLength),d="";for(let e=0;e<4;e++){e>0&&(d+="\n"),d+="		";for(let f=0;f<4;f++)f>0&&(d+=" "),d+=c.getUint32(16*e+4*f).toString(16).padStart(8,"0")}return b&&(d=b+"\n"+d),d}function B(a,b){if(a.byteLength!=b.byteLength)return!1;for(var c=new Int8Array(a),d=new Int8Array(b),e=0;e!=a.byteLength;e++)if(c[e]!=d[e])return!1;return!0}function C(a){let b=a.getPartialHash(),c=q.default(64);return c.setPartialHash(b),c}async function D(a,b,c,d,e){if(a.G1.isZero(b)||a.G1.isZero(c)||a.G2.isZero(d)||a.G2.isZero(e))return!1;let f=await a.pairingEq(b,e,a.G1.neg(c),d);return f}function E(){return window.prompt("Enter a random text. (Entropy): ","")}async function F(a){for(;!a;)a=await E();let b=q.default(64);b.update(r.default.randomBytes(64));let c=new TextEncoder;b.update(c.encode(a));let e=d.from(b.digest()),g=[];for(let h=0;h<8;h++)g[h]=e.readUInt32BE(4*h);let i=new f.ChaCha(g);return i}function G(a,b){let c,d;b<32?(c=1<<b>>>0,d=1):(c=4294967296,d=1<<b-32>>>0);let e=a;for(let g=0;g<d;g++)for(let h=0;h<c;h++)e=r.default.createHash("sha256").update(e).digest();let i=new DataView(e.buffer,e.byteOffset,e.byteLength),j=[];for(let k=0;k<8;k++)j[k]=i.getUint32(4*k,!1);let l=new f.ChaCha(j);return l}function H(a){return a instanceof Uint8Array?a:("0x"==a.slice(0,2)&&(a=a.slice(2)),new Uint8Array(a.match(/[\da-f]{2}/gi).map(function(a){return parseInt(a,16)})))}function I(a){return Array.prototype.map.call(a,function(a){return("0"+(255&a).toString(16)).slice(-2)}).join("")}function J(a,b){if(b instanceof Uint8Array)return a.toString(b);if(Array.isArray(b))return b.map(J.bind(null,a));if("object"==typeof b){let c={},d=Object.keys(b);return d.forEach(d=>{c[d]=J(a,b[d])}),c}if("bigint"==typeof b|| void 0!==b.eq)return b.toString(10);return b}async function K(a,b){await p.startWriteSection(a,1),await a.writeULE32(1),await p.endWriteSection(a);let c=await x(b.q);await p.startWriteSection(a,2);let d=c.q,e=(Math.floor((f.Scalar.bitLength(d)-1)/64)+1)*8,g=c.r,h=(Math.floor((f.Scalar.bitLength(g)-1)/64)+1)*8;await a.writeULE32(e),await p.writeBigInt(a,d,e),await a.writeULE32(h),await p.writeBigInt(a,g,h),await a.writeULE32(b.nVars),await a.writeULE32(b.nPublic),await a.writeULE32(b.domainSize),await L(a,c,b.vk_alpha_1),await L(a,c,b.vk_beta_1),await M(a,c,b.vk_beta_2),await M(a,c,b.vk_gamma_2),await L(a,c,b.vk_delta_1),await M(a,c,b.vk_delta_2),await p.endWriteSection(a)}async function L(a,b,c){let d=new Uint8Array(2*b.G1.F.n8);b.G1.toRprLEM(d,0,c),await a.write(d)}async function M(a,b,c){let d=new Uint8Array(2*b.G2.F.n8);b.G2.toRprLEM(d,0,c),await a.write(d)}async function N(a,b,c){let d=await a.read(2*b.G1.F.n8),e=b.G1.fromRprLEM(d,0);return c?b.G1.toObject(e):e}async function O(a,b,c){let d=await a.read(2*b.G2.F.n8),e=b.G2.fromRprLEM(d,0);return c?b.G2.toObject(e):e}async function P(a,b,c){await p.startReadUniqueSection(a,b,1);let d=await a.readULE32();if(await p.endReadSection(a),1==d)return await Q(a,b,c);if(2==d)return await R(a,b,c);throw Error("Protocol not supported: ")}async function Q(a,b,c){let d={};d.protocol="groth16",await p.startReadUniqueSection(a,b,2);let e=await a.readULE32();d.n8q=e,d.q=await p.readBigInt(a,e);let f=await a.readULE32();return d.n8r=f,d.r=await p.readBigInt(a,f),d.curve=await x(d.q),d.nVars=await a.readULE32(),d.nPublic=await a.readULE32(),d.domainSize=await a.readULE32(),d.power=z(d.domainSize),d.vk_alpha_1=await N(a,d.curve,c),d.vk_beta_1=await N(a,d.curve,c),d.vk_beta_2=await O(a,d.curve,c),d.vk_gamma_2=await O(a,d.curve,c),d.vk_delta_1=await N(a,d.curve,c),d.vk_delta_2=await O(a,d.curve,c),await p.endReadSection(a),d}async function R(a,b,c){let d={};d.protocol="plonk",await p.startReadUniqueSection(a,b,2);let e=await a.readULE32();d.n8q=e,d.q=await p.readBigInt(a,e);let f=await a.readULE32();return d.n8r=f,d.r=await p.readBigInt(a,f),d.curve=await x(d.q),d.nVars=await a.readULE32(),d.nPublic=await a.readULE32(),d.domainSize=await a.readULE32(),d.power=z(d.domainSize),d.nAdditions=await a.readULE32(),d.nConstrains=await a.readULE32(),d.k1=await a.read(f),d.k2=await a.read(f),d.Qm=await N(a,d.curve,c),d.Ql=await N(a,d.curve,c),d.Qr=await N(a,d.curve,c),d.Qo=await N(a,d.curve,c),d.Qc=await N(a,d.curve,c),d.S1=await N(a,d.curve,c),d.S2=await N(a,d.curve,c),d.S3=await N(a,d.curve,c),d.X_2=await O(a,d.curve,c),await p.endReadSection(a),d}async function S(a,b){let{fd:c,sections:d}=await p.readBinFile(a,"zkey",1),e=await P(c,d,b),g=new f.F1Field(e.r),h=f.Scalar.mod(f.Scalar.shl(1,8*e.n8r),e.r),i=g.inv(h),j=g.mul(i,i),k=await x(e.q);await p.startReadUniqueSection(c,d,3),e.IC=[];for(let l=0;l<=e.nPublic;l++){let m=await N(c,k,b);e.IC.push(m)}await p.endReadSection(c),await p.startReadUniqueSection(c,d,4);let n=await c.readULE32();e.ccoefs=[];for(let o=0;o<n;o++){let q=await c.readULE32(),r=await c.readULE32(),s=await c.readULE32(),t=await F();e.ccoefs.push({matrix:q,constraint:r,signal:s,value:t})}await p.endReadSection(c),await p.startReadUniqueSection(c,d,5),e.A=[];for(let u=0;u<e.nVars;u++){let v=await N(c,k,b);e.A[u]=v}await p.endReadSection(c),await p.startReadUniqueSection(c,d,6),e.B1=[];for(let w=0;w<e.nVars;w++){let y=await N(c,k,b);e.B1[w]=y}await p.endReadSection(c),await p.startReadUniqueSection(c,d,7),e.B2=[];for(let z=0;z<e.nVars;z++){let A=await O(c,k,b);e.B2[z]=A}await p.endReadSection(c),await p.startReadUniqueSection(c,d,8),e.C=[];for(let B=e.nPublic+1;B<e.nVars;B++){let C=await N(c,k,b);e.C[B]=C}await p.endReadSection(c),await p.startReadUniqueSection(c,d,9),e.hExps=[];for(let D=0;D<e.domainSize;D++){let E=await N(c,k,b);e.hExps.push(E)}return await p.endReadSection(c),await c.close(),e;async function F(){let a=await p.readBigInt(c,e.n8r);return g.mul(a,j)}}async function T(a,b,c){let d={delta:{}};d.deltaAfter=await N(a,b,c),d.delta.g1_s=await N(a,b,c),d.delta.g1_sx=await N(a,b,c),d.delta.g2_spx=await O(a,b,c),d.transcript=await a.read(64),d.type=await a.readULE32();let e=await a.readULE32(),f=a.pos,g=0;for(;a.pos-f<e;){let h=await a.read(1);if(h[0]<=g)throw Error("Parameters in the contribution must be sorted");if(g=h[0],1==h[0]){let i=await a.read(1),j=await a.read(i[0]);d.name=new TextDecoder().decode(j)}else if(2==h[0]){let k=await a.read(1);d.numIterationsExp=k[0]}else if(3==h[0]){let l=await a.read(1);d.beaconHash=await a.read(l[0])}else throw Error("Parameter not recognized")}if(a.pos!=f+e)throw Error("Parametes do not match");return d}async function U(a,b,c){await p.startReadUniqueSection(a,c,10);let d={contributions:[]};d.csHash=await a.read(64);let e=await a.readULE32();for(let f=0;f<e;f++){let g=await T(a,b);d.contributions.push(g)}return await p.endReadSection(a),d}async function V(a,b,c){await L(a,b,c.deltaAfter),await L(a,b,c.delta.g1_s),await L(a,b,c.delta.g1_sx),await M(a,b,c.delta.g2_spx),await a.write(c.transcript),await a.writeULE32(c.type||0);let d=[];if(c.name){d.push(1);let e=new TextEncoder("utf-8").encode(c.name.substring(0,64));d.push(e.byteLength);for(let f=0;f<e.byteLength;f++)d.push(e[f])}if(1==c.type){d.push(2),d.push(c.numIterationsExp),d.push(3),d.push(c.beaconHash.byteLength);for(let g=0;g<c.beaconHash.byteLength;g++)d.push(c.beaconHash[g])}if(d.length>0){let h=new Uint8Array(d);await a.writeULE32(h.byteLength),await a.write(h)}else await a.writeULE32(0)}async function W(a,b,c){await p.startWriteSection(a,10),await a.write(c.csHash),await a.writeULE32(c.contributions.length);for(let d=0;d<c.contributions.length;d++)await V(a,b,c.contributions[d]);await p.endWriteSection(a)}function X(a,b,c){let d=new Uint8Array(2*b.G1.F.n8);b.G1.toRprUncompressed(d,0,c),a.update(d)}function Y(a,b,c){X(a,b,c.deltaAfter),X(a,b,c.delta.g1_s),X(a,b,c.delta.g1_sx),function(a,b,c){let d=new Uint8Array(2*b.G2.F.n8);b.G2.toRprUncompressed(d,0,c),a.update(d)}(a,b,c.delta.g2_spx),a.update(c.transcript)}async function Z(a,b,c){await p.startWriteSection(a,1);let d=(Math.floor((f.Scalar.bitLength(c)-1)/64)+1)*8;await a.writeULE32(d),await p.writeBigInt(a,c,d),await a.writeULE32(b.length),await p.endWriteSection(a),await p.startWriteSection(a,2);for(let e=0;e<b.length;e++)await p.writeBigInt(a,b[e],d);await p.endWriteSection(a,2)}async function $(a,b,c){await p.startWriteSection(a,1);let d=(Math.floor((f.Scalar.bitLength(c)-1)/64)+1)*8;if(await a.writeULE32(d),await p.writeBigInt(a,c,d),b.byteLength%d!=0)throw Error("Invalid witness length");await a.writeULE32(b.byteLength/d),await p.endWriteSection(a),await p.startWriteSection(a,2),await a.write(b),await p.endWriteSection(a)}async function _(a,b){await p.startReadUniqueSection(a,b,1);let c=await a.readULE32(),d=await p.readBigInt(a,c),e=await a.readULE32();return await p.endReadSection(a),{n8:c,q:d,nWitness:e}}async function aa(a){let{fd:b,sections:c}=await p.readBinFile(a,"wtns",2),{n8:d,nWitness:e}=await _(b,c);await p.startReadUniqueSection(b,c,2);let f=[];for(let g=0;g<e;g++){let h=await p.readBigInt(b,d);f.push(h)}return await p.endReadSection(b),await b.close(),f}let{stringifyBigInts:ab}=f.utils;async function ac(a,b,c){let{fd:d,sections:e}=await p.readBinFile(b,"wtns",2,33554432,8388608),g=await _(d,e),{fd:h,sections:i}=await p.readBinFile(a,"zkey",2,33554432,8388608),j=await P(h,i);if("groth16"!=j.protocol)throw Error("zkey file is not groth16");if(!f.Scalar.eq(j.r,g.q))throw Error("Curve of the witness does not match the curve of the proving key");if(g.nWitness!=j.nVars)throw Error(`Invalid witness length. Circuit: ${j.nVars}, witness: ${g.nWitness}`);let k=j.curve,l=k.Fr,m=k.G1,n=k.G2,o=z(j.domainSize);c&&c.debug("Reading Wtns");let q=await p.readSection(d,e,2);c&&c.debug("Reading Coeffs");let r=await p.readSection(h,i,4);c&&c.debug("Building ABC");let[s,t,u]=await ad(k,j,q,r,c),v=o==l.s?k.Fr.shift:k.Fr.w[o+1],w=await l.ifft(s,"","",c,"IFFT_A"),x=await l.batchApplyKey(w,l.e(1),v),y=await l.fft(x,"","",c,"FFT_A"),A=await l.ifft(t,"","",c,"IFFT_B"),B=await l.batchApplyKey(A,l.e(1),v),C=await l.fft(B,"","",c,"FFT_B"),D=await l.ifft(u,"","",c,"IFFT_C"),E=await l.batchApplyKey(D,l.e(1),v),F=await l.fft(E,"","",c,"FFT_C");c&&c.debug("Join ABC");let G=await ae(k,j,y,C,F,c),H={};c&&c.debug("Reading A Points");let I=await p.readSection(h,i,5);H.pi_a=await k.G1.multiExpAffine(I,q,c,"multiexp A"),c&&c.debug("Reading B1 Points");let J=await p.readSection(h,i,6),K=await k.G1.multiExpAffine(J,q,c,"multiexp B1");c&&c.debug("Reading B2 Points");let L=await p.readSection(h,i,7);H.pi_b=await k.G2.multiExpAffine(L,q,c,"multiexp B2"),c&&c.debug("Reading C Points");let M=await p.readSection(h,i,8);H.pi_c=await k.G1.multiExpAffine(M,q.slice((j.nPublic+1)*k.Fr.n8),c,"multiexp C"),c&&c.debug("Reading H Points");let N=await p.readSection(h,i,9),O=await k.G1.multiExpAffine(N,G,c,"multiexp H"),Q=k.Fr.random(),R=k.Fr.random();H.pi_a=m.add(H.pi_a,j.vk_alpha_1),H.pi_a=m.add(H.pi_a,m.timesFr(j.vk_delta_1,Q)),H.pi_b=n.add(H.pi_b,j.vk_beta_2),H.pi_b=n.add(H.pi_b,n.timesFr(j.vk_delta_2,R)),K=m.add(K,j.vk_beta_1),K=m.add(K,m.timesFr(j.vk_delta_1,R)),H.pi_c=m.add(H.pi_c,O),H.pi_c=m.add(H.pi_c,m.timesFr(H.pi_a,R)),H.pi_c=m.add(H.pi_c,m.timesFr(K,Q)),H.pi_c=m.add(H.pi_c,m.timesFr(j.vk_delta_1,l.neg(l.mul(Q,R))));let S=[];for(let T=1;T<=j.nPublic;T++){let U=q.slice(T*l.n8,T*l.n8+l.n8);S.push(f.Scalar.fromRprLE(U))}return H.pi_a=m.toObject(m.toAffine(H.pi_a)),H.pi_b=n.toObject(n.toAffine(H.pi_b)),H.pi_c=m.toObject(m.toAffine(H.pi_c)),H.protocol="groth16",H.curve=k.name,await h.close(),await d.close(),H=ab(H),S=ab(S),{proof:H,publicSignals:S}}async function ad(a,b,c,d,e){let g=a.Fr.n8,h=12+b.n8r,i=(d.byteLength-4)/h,j=new f.BigBuffer(b.domainSize*g),k=new f.BigBuffer(b.domainSize*g),l=new f.BigBuffer(b.domainSize*g),m=[j,k];for(let n=0;n<i;n++){e&&n%1e6==0&&e.debug(`QAP AB: ${n}/${i}`);let o=d.slice(4+n*h,4+n*h+h),p=new DataView(o.buffer),q=p.getUint32(0,!0),r=p.getUint32(4,!0),s=p.getUint32(8,!0),t=o.slice(12,12+g);m[q].set(a.Fr.add(m[q].slice(r*g,r*g+g),a.Fr.mul(t,c.slice(s*g,s*g+g))),r*g)}for(let u=0;u<b.domainSize;u++)e&&u%1e6==0&&e.debug(`QAP C: ${u}/${b.domainSize}`),l.set(a.Fr.mul(j.slice(u*g,u*g+g),k.slice(u*g,u*g+g)),u*g);return[j,k,l]}async function ae(a,b,c,d,e,g){let h=a.Fr.n8,i=Math.floor(c.byteLength/a.Fr.n8),j=[];for(let k=0;k<i;k+=4194304){g&&g.debug(`JoinABC: ${k}/${i}`);let l=Math.min(i-k,4194304),m=[],n=c.slice(k*h,(k+l)*h),o=d.slice(k*h,(k+l)*h),p=e.slice(k*h,(k+l)*h);m.push({cmd:"ALLOCSET",var:0,buff:n}),m.push({cmd:"ALLOCSET",var:1,buff:o}),m.push({cmd:"ALLOCSET",var:2,buff:p}),m.push({cmd:"ALLOC",var:3,len:l*h}),m.push({cmd:"CALL",fnName:"qap_joinABC",params:[{var:0},{var:1},{var:2},{val:l},{var:3},]}),m.push({cmd:"CALL",fnName:"frm_batchFromMontgomery",params:[{var:3},{val:l},{var:3}]}),m.push({cmd:"GET",out:0,var:3,len:l*h}),j.push(a.tm.queueAction(m))}let q=await Promise.all(j),r;r=c instanceof f.BigBuffer?new f.BigBuffer(c.byteLength):new Uint8Array(c.byteLength);let s=0;for(let t=0;t<q.length;t++)r.set(q[t][0],s),s+=q[t][0].byteLength;return r}let{unstringifyBigInts:af}=f.utils;async function ag(a,b,c,d){let e=af(a),f=await s.readExisting(b),g=await f.read(f.totalSize);await f.close();let h=await j.WitnessCalculatorBuilder(g);if(1==h.circom_version()){let i=await h.calculateBinWitness(e),k=await p.createBinFile(c,"wtns",2,2);await $(k,i,h.prime),await k.close()}else{let l=await s.createOverride(c),m=await h.calculateWTNSBin(e);await l.write(m),await l.close()}}let{unstringifyBigInts:ah}=f.utils;async function ai(a,b,c,d){let e=ah(a),f={type:"mem"};return await ag(e,b,f),await ac(c,f,d)}let{unstringifyBigInts:aj}=f.utils;async function ak(a,b,c,d){let e=aj(a),g=aj(c),h=aj(b),i=await y(e.curve),j=i.G1.fromObject(e.IC[0]),k=new Uint8Array(2*i.G1.F.n8*h.length),l=new Uint8Array(i.Fr.n8*h.length);for(let m=0;m<h.length;m++){let n=i.G1.fromObject(e.IC[m+1]);k.set(n,m*i.G1.F.n8*2),f.Scalar.toRprLE(l,i.Fr.n8*m,h[m],i.Fr.n8)}let o=await i.G1.multiExpAffine(k,l);o=i.G1.add(o,j);let p=i.G1.fromObject(g.pi_a),q=i.G2.fromObject(g.pi_b),r=i.G1.fromObject(g.pi_c),s=i.G2.fromObject(e.vk_gamma_2),t=i.G2.fromObject(e.vk_delta_2),u=i.G1.fromObject(e.vk_alpha_1),v=i.G2.fromObject(e.vk_beta_2),w=await i.pairingEq(i.G1.neg(p),q,o,s,r,t,u,v);return w?(d&&d.info("OK!"),!0):(d&&d.error("Invalid proof"),!1)}let{unstringifyBigInts:al}=f.utils;function am(a){let b=a.toString(16);for(;b.length<64;)b="0"+b;return`"0x${b}"`}async function an(a,b){let c=al(a),d=al(b),e="";for(let f=0;f<d.length;f++)""!=e&&(e+=","),e+=am(d[f]);let g;return`[${am(c.pi_a[0])}, ${am(c.pi_a[1])}],[[${am(c.pi_b[0][1])}, ${am(c.pi_b[0][0])}],[${am(c.pi_b[1][1])}, ${am(c.pi_b[1][0])}]],[${am(c.pi_c[0])}, ${am(c.pi_c[1])}],[${e}]`}var ao=Object.freeze({__proto__:null,fullProve:ai,prove:ac,verify:ak,exportSolidityCallData:an});function ap(a,b){let c=new DataView(b.buffer,b.byteOffset,b.byteLength),d=[];for(let e=0;e<8;e++)d[e]=c.getUint32(4*e);let g=new f.ChaCha(d),h=a.G2.fromRng(g);return h}function aq(a,b,c,d,e){let f=q.default(64),g=new Uint8Array([b]);f.update(g),f.update(c);let h=a.G1.toUncompressed(d);f.update(h);let i=a.G1.toUncompressed(e);f.update(i);let j=f.digest();return ap(a,j)}function ar(a,b,c,d,e){return a.g1_s=b.G1.toAffine(b.G1.fromRng(e)),a.g1_sx=b.G1.toAffine(b.G1.timesFr(a.g1_s,a.prvKey)),a.g2_sp=b.G2.toAffine(aq(b,c,d,a.g1_s,a.g1_sx)),a.g2_spx=b.G2.toAffine(b.G2.timesFr(a.g2_sp,a.prvKey)),a}function as(a,b,c){let d={tau:{},alpha:{},beta:{}};return d.tau.prvKey=a.Fr.fromRng(c),d.alpha.prvKey=a.Fr.fromRng(c),d.beta.prvKey=a.Fr.fromRng(c),ar(d.tau,a,0,b,c),ar(d.alpha,a,1,b,c),ar(d.beta,a,2,b,c),d}async function at(a,b,c,d){d||(d=c),await a.writeULE32(1);let e=a.pos;await a.writeULE64(0),await a.writeULE32(8*b.F1.n64);let g=new Uint8Array(b.F1.n8);f.Scalar.toRprLE(g,0,b.q,b.F1.n8),await a.write(g),await a.writeULE32(c),await a.writeULE32(d);let h=a.pos-e-8,i=a.pos;await a.writeULE64(h,e),a.pos=i}async function au(a,b){if(!b[1])throw Error(a.fileName+": File has no  header");if(b[1].length>1)throw Error(a.fileName+": File has more than one header");a.pos=b[1][0].p;let c=await a.readULE32(),d=await a.read(c),e=f.Scalar.fromRprLE(d),g=await x(e);if(8*g.F1.n64!=c)throw Error(a.fileName+": Invalid size");let h=await a.readULE32(),i=await a.readULE32();if(a.pos-b[1][0].p!=b[1][0].size)throw Error("Invalid PTau header size");return{curve:g,power:h,ceremonyPower:i}}async function av(a,b,c){let d=await a.read(12*b.F1.n8+6*b.F2.n8);return aw(d,0,b,c)}function aw(a,b,c,d){let e={tau:{},alpha:{},beta:{}};return e.tau.g1_s=f(),e.tau.g1_sx=f(),e.alpha.g1_s=f(),e.alpha.g1_sx=f(),e.beta.g1_s=f(),e.beta.g1_sx=f(),e.tau.g2_spx=g(),e.alpha.g2_spx=g(),e.beta.g2_spx=g(),e;function f(){let e;return e=d?c.G1.fromRprLEM(a,b):c.G1.fromRprUncompressed(a,b),b+=2*c.G1.F.n8,e}function g(){let e;return e=d?c.G2.fromRprLEM(a,b):c.G2.fromRprUncompressed(a,b),b+=2*c.G2.F.n8,e}}function ax(a,b,c,d,e){async function f(d){e?c.G1.toRprLEM(a,b,d):c.G1.toRprUncompressed(a,b,d),b+=2*c.F1.n8}async function g(d){e?c.G2.toRprLEM(a,b,d):c.G2.toRprUncompressed(a,b,d),b+=2*c.F2.n8}return f(d.tau.g1_s),f(d.tau.g1_sx),f(d.alpha.g1_s),f(d.alpha.g1_sx),f(d.beta.g1_s),f(d.beta.g1_sx),g(d.tau.g2_spx),g(d.alpha.g2_spx),g(d.beta.g2_spx),a}async function ay(a,b,c,d){let e=new Uint8Array(12*b.F1.n8+6*b.F2.n8);ax(e,0,b,c,d),await a.write(e)}async function az(a,b){let c={};c.tauG1=await n(),c.tauG2=await o(),c.alphaG1=await n(),c.betaG1=await n(),c.betaG2=await o(),c.key=await av(a,b,!0),c.partialHash=await a.read(216),c.nextChallenge=await a.read(64),c.type=await a.readULE32();let d=new Uint8Array(12*b.G1.F.n8+6*b.G2.F.n8);ax(d,0,b,c.key,!1);let e=q.default(64);e.setPartialHash(c.partialHash),e.update(d),c.responseHash=e.digest();let f=await a.readULE32(),g=a.pos,h=0;for(;a.pos-g<f;){let i=await p(1);if(i[0]<=h)throw Error("Parameters in the contribution must be sorted");if(h=i[0],1==i[0]){let j=await p(1),k=await p(j[0]);c.name=new TextDecoder().decode(k)}else if(2==i[0]){let l=await p(1);c.numIterationsExp=l[0]}else if(3==i[0]){let m=await p(1);c.beaconHash=await p(m[0])}else throw Error("Parameter not recognized")}if(a.pos!=g+f)throw Error("Parametes do not match");return c;async function n(){let c=await a.read(2*b.G1.F.n8);return b.G1.fromRprLEM(c)}async function o(){let c=await a.read(2*b.G2.F.n8);return b.G2.fromRprLEM(c)}async function p(b){let c=await a.read(b);return new Uint8Array(c)}}async function aA(a,b,c){if(!c[7])throw Error(a.fileName+": File has no  contributions");if(c[7][0].length>1)throw Error(a.fileName+": File has more than one contributions section");a.pos=c[7][0].p;let d=await a.readULE32(),e=[];for(let f=0;f<d;f++){let g=await az(a,b);g.id=f+1,e.push(g)}if(a.pos-c[7][0].p!=c[7][0].size)throw Error("Invalid contribution section size");return e}async function aB(a,b,c){let d=new Uint8Array(2*b.F1.n8),e=new Uint8Array(2*b.F2.n8);await k(c.tauG1),await l(c.tauG2),await k(c.alphaG1),await k(c.betaG1),await l(c.betaG2),await ay(a,b,c.key,!0),await a.write(c.partialHash),await a.write(c.nextChallenge),await a.writeULE32(c.type||0);let f=[];if(c.name){f.push(1);let g=new TextEncoder("utf-8").encode(c.name.substring(0,64));f.push(g.byteLength);for(let h=0;h<g.byteLength;h++)f.push(g[h])}if(1==c.type){f.push(2),f.push(c.numIterationsExp),f.push(3),f.push(c.beaconHash.byteLength);for(let i=0;i<c.beaconHash.byteLength;i++)f.push(c.beaconHash[i])}if(f.length>0){let j=new Uint8Array(f);await a.writeULE32(j.byteLength),await a.write(j)}else await a.writeULE32(0);async function k(c){b.G1.toRprLEM(d,0,c),await a.write(d)}async function l(c){b.G2.toRprLEM(e,0,c),await a.write(e)}}async function aC(a,b,c){await a.writeULE32(7);let d=a.pos;await a.writeULE64(0),await a.writeULE32(c.length);for(let e=0;e<c.length;e++)await aB(a,b,c[e]);let f=a.pos-d-8,g=a.pos;await a.writeULE64(f,d),a.pos=g}function aD(a,b,c){c&&c.debug("Calculating First Challenge Hash");let d=new q.default(64),e=new Uint8Array(2*a.G1.F.n8),f=new Uint8Array(2*a.G2.F.n8);a.G1.toRprUncompressed(e,0,a.G1.g),a.G2.toRprUncompressed(f,0,a.G2.g),d.update(q.default(64).digest());let g;return g=2**b*2-1,c&&c.debug("Calculate Initial Hash: tauG1"),h(e,g),g=2**b,c&&c.debug("Calculate Initial Hash: tauG2"),h(f,g),c&&c.debug("Calculate Initial Hash: alphaTauG1"),h(e,g),c&&c.debug("Calculate Initial Hash: betaTauG1"),h(e,g),d.update(f),d.digest();function h(a,b){let e=Math.floor(b/341e3),f=b%341e3,g=new Uint8Array(341e3*a.byteLength);for(let h=0;h<341e3;h++)g.set(a,h*a.byteLength);for(let i=0;i<e;i++)d.update(g),c&&c.debug("Initial hash: "+341e3*i);for(let j=0;j<f;j++)d.update(a)}}function aE(a,b,c,d){let e=G(c,d),f=as(a,b,e);return f}async function aF(a,b,c,d){await q.default.ready();let e=await p.createBinFile(c,"ptau",1,7);await at(e,a,b,0);let f=a.G1.oneAffine,g=a.G2.oneAffine;await p.startWriteSection(e,2);let h=2**b*2-1;for(let i=0;i<h;i++)await e.write(f),d&&i%1e5==0&&i&&d.log("tauG1: "+i);await p.endWriteSection(e),await p.startWriteSection(e,3);let j=2**b;for(let k=0;k<j;k++)await e.write(g),d&&k%1e5==0&&k&&d.log("tauG2: "+k);await p.endWriteSection(e),await p.startWriteSection(e,4);let l=2**b;for(let m=0;m<l;m++)await e.write(f),d&&m%1e5==0&&m&&d.log("alphaTauG1: "+m);await p.endWriteSection(e),await p.startWriteSection(e,5);let n=2**b;for(let o=0;o<n;o++)await e.write(f),d&&o%1e5==0&&o&&d.log("betaTauG1: "+o);await p.endWriteSection(e),await p.startWriteSection(e,6),await e.write(g),await p.endWriteSection(e),await p.startWriteSection(e,7),await e.writeULE32(0),await p.endWriteSection(e),await e.close();let r=aD(a,b,d);return d&&d.debug(A(q.default(64).digest(),"Blank Contribution Hash:")),d&&d.info(A(r,"First Contribution Hash:")),r}async function aG(a,b,c){await q.default.ready();let{fd:d,sections:e}=await p.readBinFile(a,"ptau",1),{curve:f,power:g}=await au(d,e),h=await aA(d,f,e),i,j;0==h.length?(i=q.default(64).digest(),j=aD(f,g)):(i=h[h.length-1].responseHash,j=h[h.length-1].nextChallenge),c&&c.info(A(i,"Last Response Hash: ")),c&&c.info(A(j,"New Challenge Hash: "));let k=await s.createOverride(b),l=q.default(64);await k.write(i),l.update(i),await n(2,"G1",2**g*2-1,"tauG1"),await n(3,"G2",2**g,"tauG2"),await n(4,"G1",2**g,"alphaTauG1"),await n(5,"G1",2**g,"betaTauG1"),await n(6,"G2",1,"betaG2"),await d.close(),await k.close();let m=l.digest();if(!B(j,m))throw c&&c.info(A(m,"Calc Curret Challenge Hash: ")),c&&c.error("PTau file is corrupted. Calculated new challenge hash does not match with the eclared one"),Error("PTau file is corrupted. Calculated new challenge hash does not match with the eclared one");return j;async function n(a,b,g,h){let i=f[b],j=2*i.F.n8,m=Math.floor(16777216/j);await p.startReadUniqueSection(d,e,a);for(let n=0;n<g;n+=m){c&&c.debug(`Exporting ${h}: ${n}/${g}`);let o=Math.min(g-n,m),q;await k.write(q=await i.batchLEMtoU(q=await d.read(o*j))),l.update(q)}await p.endReadSection(d)}}async function aH(a,b,c,d,e,f){await q.default.ready();let g=new Uint8Array(64);for(let h=0;h<64;h++)g[h]=255;let{fd:i,sections:j}=await p.readBinFile(a,"ptau",1),{curve:k,power:l}=await au(i,j),m=await aA(i,k,j),n={};d&&(n.name=d);let o=2*k.F1.n8,r=k.F1.n8,t=2*k.F2.n8,u=k.F2.n8,v=await s.readExisting(b);if(v.totalSize!=64+(2**l*2-1)*r+2**l*u+2**l*r+2**l*r+u+6*o+3*t)throw Error("Size of the contribution is invalid");let w;w=m.length>0?m[m.length-1].nextChallenge:aD(k,l,f);let x=await p.createBinFile(c,"ptau",1,e?7:2);await at(x,k,l);let y=await v.read(64);if(B(g,w)&&(w=y,m[m.length-1].nextChallenge=w),!B(y,w))throw Error("Wrong contribution. this contribution is not based on the previus hash");let z=new q.default(64);z.update(y);let C=[],D;D=await H(v,x,"G1",2,2**l*2-1,[1],"tauG1"),n.tauG1=D[0],D=await H(v,x,"G2",3,2**l,[1],"tauG2"),n.tauG2=D[0],D=await H(v,x,"G1",4,2**l,[0],"alphaG1"),n.alphaG1=D[0],D=await H(v,x,"G1",5,2**l,[0],"betaG1"),n.betaG1=D[0],D=await H(v,x,"G2",6,1,[0],"betaG2"),n.betaG2=D[0],n.partialHash=z.getPartialHash();let E=await v.read(12*k.F1.n8+6*k.F2.n8);n.key=aw(E,0,k,!1),z.update(new Uint8Array(E));let F=z.digest();if(f&&f.info(A(F,"Contribution Response Hash imported: ")),e){let G=new q.default(64);G.update(F),await K(G,x,"G1",2,2**l*2-1,"tauG1",f),await K(G,x,"G2",3,2**l,"tauG2",f),await K(G,x,"G1",4,2**l,"alphaTauG1",f),await K(G,x,"G1",5,2**l,"betaTauG1",f),await K(G,x,"G2",6,1,"betaG2",f),n.nextChallenge=G.digest(),f&&f.info(A(n.nextChallenge,"Next Challenge Hash: "))}else n.nextChallenge=g;return m.push(n),await aC(x,k,m),await v.close(),await x.close(),await i.close(),n.nextChallenge;async function H(a,b,c,d,f,g,h){return e?await I(a,b,c,d,f,g,h):await J(a,b,c,d,f,g,h)}async function I(a,b,c,d,e,g,h){let i=k[c],j=i.F.n8,l=2*i.F.n8,m=[];await p.startWriteSection(b,d);let n=Math.floor(16777216/l);C[d]=b.pos;for(let o=0;o<e;o+=n){f&&f.debug(`Importing ${h}: ${o}/${e}`);let q=Math.min(e-o,n),r=await a.read(q*j);z.update(r);let s=await i.batchCtoLEM(r);await b.write(s);for(let t=0;t<g.length;t++){let u=g[t];if(u>=o&&u<o+q){let v=i.fromRprLEM(s,(u-o)*l);m.push(v)}}}return await p.endWriteSection(b),m}async function J(a,b,c,d,e,g,h){let i=k[c],j=i.F.n8,l=[],m=Math.floor(16777216/j);for(let n=0;n<e;n+=m){f&&f.debug(`Importing ${h}: ${n}/${e}`);let o=Math.min(e-n,m),p=await a.read(o*j);z.update(p);for(let q=0;q<g.length;q++){let r=g[q];if(r>=n&&r<n+o){let s=i.fromRprCompressed(p,(r-n)*j);l.push(s)}}}return l}async function K(a,b,c,d,e,f,g){let h=k[c],i=2*h.F.n8,j=Math.floor(16777216/i),l=b.pos;b.pos=C[d];for(let m=0;m<e;m+=j){g&&g.debug(`Hashing ${f}: ${m}/${e}`);let n=Math.min(e-m,j),o=await b.read(n*i),p=await h.batchLEMtoU(o);a.update(p)}b.pos=l}}let aI=D;async function aJ(a,b,c,d){let e;if(1==b.type){let f=aE(a,c.nextChallenge,b.beaconHash,b.numIterationsExp);if(!a.G1.eq(b.key.tau.g1_s,f.tau.g1_s))return d&&d.error(`BEACON key (tauG1_s) is not generated correctly in challenge #${b.id}  ${b.name||""}`),!1;if(!a.G1.eq(b.key.tau.g1_sx,f.tau.g1_sx))return d&&d.error(`BEACON key (tauG1_sx) is not generated correctly in challenge #${b.id}  ${b.name||""}`),!1;if(!a.G2.eq(b.key.tau.g2_spx,f.tau.g2_spx))return d&&d.error(`BEACON key (tauG2_spx) is not generated correctly in challenge #${b.id}  ${b.name||""}`),!1;if(!a.G1.eq(b.key.alpha.g1_s,f.alpha.g1_s))return d&&d.error(`BEACON key (alphaG1_s) is not generated correctly in challenge #${b.id}  ${b.name||""}`),!1;if(!a.G1.eq(b.key.alpha.g1_sx,f.alpha.g1_sx))return d&&d.error(`BEACON key (alphaG1_sx) is not generated correctly in challenge #${b.id}  ${b.name||""}`),!1;if(!a.G2.eq(b.key.alpha.g2_spx,f.alpha.g2_spx))return d&&d.error(`BEACON key (alphaG2_spx) is not generated correctly in challenge #${b.id}  ${b.name||""}`),!1;if(!a.G1.eq(b.key.beta.g1_s,f.beta.g1_s))return d&&d.error(`BEACON key (betaG1_s) is not generated correctly in challenge #${b.id}  ${b.name||""}`),!1;if(!a.G1.eq(b.key.beta.g1_sx,f.beta.g1_sx))return d&&d.error(`BEACON key (betaG1_sx) is not generated correctly in challenge #${b.id}  ${b.name||""}`),!1;if(!a.G2.eq(b.key.beta.g2_spx,f.beta.g2_spx))return d&&d.error(`BEACON key (betaG2_spx) is not generated correctly in challenge #${b.id}  ${b.name||""}`),!1}return(b.key.tau.g2_sp=a.G2.toAffine(aq(a,0,c.nextChallenge,b.key.tau.g1_s,b.key.tau.g1_sx)),b.key.alpha.g2_sp=a.G2.toAffine(aq(a,1,c.nextChallenge,b.key.alpha.g1_s,b.key.alpha.g1_sx)),b.key.beta.g2_sp=a.G2.toAffine(aq(a,2,c.nextChallenge,b.key.beta.g1_s,b.key.beta.g1_sx)),!0!==await aI(a,b.key.tau.g1_s,b.key.tau.g1_sx,b.key.tau.g2_sp,b.key.tau.g2_spx))?(d&&d.error("INVALID key (tau) in challenge #"+b.id),!1):!0!==await aI(a,b.key.alpha.g1_s,b.key.alpha.g1_sx,b.key.alpha.g2_sp,b.key.alpha.g2_spx)?(d&&d.error("INVALID key (alpha) in challenge #"+b.id),!1):!0!==await aI(a,b.key.beta.g1_s,b.key.beta.g1_sx,b.key.beta.g2_sp,b.key.beta.g2_spx)?(d&&d.error("INVALID key (beta) in challenge #"+b.id),!1):!0!==await aI(a,c.tauG1,b.tauG1,b.key.tau.g2_sp,b.key.tau.g2_spx)?(d&&d.error("INVALID tau*G1. challenge #"+b.id+" It does not follow the previous contribution"),!1):!0!==await aI(a,b.key.tau.g1_s,b.key.tau.g1_sx,c.tauG2,b.tauG2)?(d&&d.error("INVALID tau*G2. challenge #"+b.id+" It does not follow the previous contribution"),!1):!0!==await aI(a,c.alphaG1,b.alphaG1,b.key.alpha.g2_sp,b.key.alpha.g2_spx)?(d&&d.error("INVALID alpha*G1. challenge #"+b.id+" It does not follow the previous contribution"),!1):!0!==await aI(a,c.betaG1,b.betaG1,b.key.beta.g2_sp,b.key.beta.g2_spx)?(d&&d.error("INVALID beta*G1. challenge #"+b.id+" It does not follow the previous contribution"),!1):!0!==await aI(a,b.key.beta.g1_s,b.key.beta.g1_sx,c.betaG2,b.betaG2)?(d&&d.error("INVALID beta*G2. challenge #"+b.id+"It does not follow the previous contribution"),!1):(d&&d.info("Powers Of tau file OK!"),!0)}async function aK(a,b){let c;await q.default.ready();let{fd:d,sections:e}=await p.readBinFile(a,"ptau",1),{curve:g,power:h,ceremonyPower:i}=await au(d,e),j=await aA(d,g,e);b&&b.debug("power: 2**"+h),b&&b.debug("Computing initial contribution hash");let k={tauG1:g.G1.g,tauG2:g.G2.g,alphaG1:g.G1.g,betaG1:g.G1.g,betaG2:g.G2.g,nextChallenge:aD(g,i,b),responseHash:q.default(64).digest()};if(0==j.length)return b&&b.error("This file has no contribution! It cannot be used in production"),!1;let l;l=j.length>1?j[j.length-2]:k;let m=j[j.length-1];b&&b.debug("Validating contribution #"+j[j.length-1].id);let n=await aJ(g,m,l,b);if(!n)return!1;let o=q.default(64);o.update(m.responseHash),b&&b.debug("Verifying powers in tau*G1 section");let s=await H(2,"G1","tauG1",2**h*2-1,[0,1],b);if(!0!==await aI(g,s.R1,s.R2,g.G2.g,m.tauG2))return b&&b.error("tauG1 section. Powers do not match"),!1;if(!g.G1.eq(g.G1.g,s.singularPoints[0]))return b&&b.error("First element of tau*G1 section must be the generator"),!1;if(!g.G1.eq(m.tauG1,s.singularPoints[1]))return b&&b.error("Second element of tau*G1 section does not match the one in the contribution section"),!1;b&&b.debug("Verifying powers in tau*G2 section");let t=await H(3,"G2","tauG2",2**h,[0,1],b);if(!0!==await aI(g,g.G1.g,m.tauG1,t.R1,t.R2))return b&&b.error("tauG2 section. Powers do not match"),!1;if(!g.G2.eq(g.G2.g,t.singularPoints[0]))return b&&b.error("First element of tau*G2 section must be the generator"),!1;if(!g.G2.eq(m.tauG2,t.singularPoints[1]))return b&&b.error("Second element of tau*G2 section does not match the one in the contribution section"),!1;b&&b.debug("Verifying powers in alpha*tau*G1 section");let u=await H(4,"G1","alphatauG1",2**h,[0],b);if(!0!==await aI(g,u.R1,u.R2,g.G2.g,m.tauG2))return b&&b.error("alphaTauG1 section. Powers do not match"),!1;if(!g.G1.eq(m.alphaG1,u.singularPoints[0]))return b&&b.error("First element of alpha*tau*G1 section (alpha*G1) does not match the one in the contribution section"),!1;b&&b.debug("Verifying powers in beta*tau*G1 section");let v=await H(5,"G1","betatauG1",2**h,[0],b);if(!0!==await aI(g,v.R1,v.R2,g.G2.g,m.tauG2))return b&&b.error("betaTauG1 section. Powers do not match"),!1;if(!g.G1.eq(m.betaG1,v.singularPoints[0]))return b&&b.error("First element of beta*tau*G1 section (beta*G1) does not match the one in the contribution section"),!1;let w=await G(b);if(!g.G2.eq(m.betaG2,w))return b&&b.error("betaG2 element in betaG2 section does not match the one in the contribution section"),!1;let x=o.digest();if(h==i&&!B(x,m.nextChallenge))return b&&b.error("Hash of the values does not match the next challenge of the last contributor in the contributions section"),!1;b&&b.info(A(x,"Next challenge hash: ")),F(m,l);for(let y=j.length-2;y>=0;y--){let z=j[y],C=y>0?j[y-1]:k,D=await aJ(g,z,C,b);if(!D)return!1;F(z,C)}if(b&&b.info("-----------------------------------------------------"),e[12]&&e[13]&&e[14]&&e[15]){let E;if(!await J("G1",2,12,"tauG1",b)||!await J("G2",3,13,"tauG2",b)||!await J("G1",4,14,"alphaTauG1",b)||!await J("G1",5,15,"betaTauG1",b))return!1}else b&&b.warn('this file does not contain phase2 precalculated values. Please run: \n   snarkjs "powersoftau preparephase2" to prepare this file to be used in the phase2 ceremony.');return await d.close(),b&&b.info("Powers of Tau Ok!"),!0;function F(a,c){if(!b)return;b.info("-----------------------------------------------------"),b.info(`Contribution #${a.id}: ${a.name||""}`),b.info(A(a.nextChallenge,"Next Challenge: "));let d=new Uint8Array(12*g.G1.F.n8+6*g.G2.F.n8);ax(d,0,g,a.key,!1);let e=q.default(64);e.setPartialHash(a.partialHash),e.update(d);let f=e.digest();b.info(A(f,"Response Hash:")),b.info(A(c.nextChallenge,"Response Hash:")),1==a.type&&(b.info(`Beacon generator: ${I(a.beaconHash)}`),b.info(`Beacon iterations Exp: ${a.numIterationsExp}`))}async function G(a){let b=g.G2,c=2*b.F.n8,f=new Uint8Array(c);if(!e[6])throw a.error("File has no BetaG2 section"),Error("File has no BetaG2 section");if(e[6].length>1)throw a.error("File has no BetaG2 section"),Error("File has more than one GetaG2 section");d.pos=e[6][0].p;let h=await d.read(c),i=b.fromRprLEM(h);return b.toRprUncompressed(f,0,i),o.update(f),i}async function H(a,b,c,f,h,i){let j=65536,k=g[b],l=2*k.F.n8;await p.startReadUniqueSection(d,e,a);let m=[],n=k.zero,q=k.zero,s=k.zero;for(let t=0;t<f;t+=j){i&&i.debug(`points relations: ${c}: ${t}/${f} `);let u=Math.min(f-t,j),v=await d.read(u*l),w=await k.batchLEMtoU(v);o.update(w);let x=new Uint8Array(4*(u-1));if(r.default.randomFillSync(x),t>0){let y=k.fromRprLEM(v,0),z=r.default.randomBytes(4).readUInt32BE(0,!0);n=k.add(n,k.timesScalar(s,z)),q=k.add(q,k.timesScalar(y,z))}let A=await k.multiExpAffine(v.slice(0,(u-1)*l),x),B=await k.multiExpAffine(v.slice(l),x);n=k.add(n,A),q=k.add(q,B),s=k.fromRprLEM(v,(u-1)*l);for(let C=0;C<h.length;C++){let D=h[C];if(D>=t&&D<t+u){let E=k.fromRprLEM(v,(D-t)*l);m.push(E)}}}return await p.endReadSection(d),{R1:n,R2:q,singularPoints:m}}async function J(a,b,c,i,j){j&&j.debug(`Verifying phase2 calculated values ${i}...`);let k=g[a],l=2*k.F.n8,m=Array(8);for(let n=0;n<8;n++)m[n]=r.default.randomBytes(4).readUInt32BE(0,!0);for(let o=0;o<=h;o++){let q=await t(o);if(!q)return!1}if(2==b){let s=await t(h+1);if(!s)return!1}return!0;async function t(a){j&&j.debug(`Power ${a}...`);let n=g.Fr.n8,o=2**a,q=new Uint32Array(o),r,s=new f.ChaCha(m);j&&j.debug(`Creating random numbers Powers${a}...`);for(let t=0;t<o;t++)a==h+1&&t==o-1?q[t]=0:q[t]=s.nextU32();q=new Uint8Array(q.buffer,q.byteOffset,q.byteLength),j&&j.debug(`reading points Powers${a}...`),await p.startReadUniqueSection(d,e,b),r=new f.BigBuffer(o*l),a==h+1?(await d.readToBuffer(r,0,(o-1)*l),r.set(g.G1.zeroAffine,(o-1)*l)):await d.readToBuffer(r,0,o*l),await p.endReadSection(d,!0);let u=await k.multiExpAffine(r,q,j,i+"_"+a);q=new f.BigBuffer(o*n),s=new f.ChaCha(m);let v=new Uint8Array(4),w=new DataView(v.buffer);j&&j.debug(`Creating random numbers Powers${a}...`);for(let x=0;x<o;x++)(x!=o-1||a!=h+1)&&(w.setUint32(0,s.nextU32(),!0),q.set(v,x*n));j&&j.debug(`batchToMontgomery ${a}...`),q=await g.Fr.batchToMontgomery(q),j&&j.debug(`fft ${a}...`),q=await g.Fr.fft(q),j&&j.debug(`batchFromMontgomery ${a}...`),q=await g.Fr.batchFromMontgomery(q),j&&j.debug(`reading points Lagrange${a}...`),await p.startReadUniqueSection(d,e,c),d.pos+=l*(2**a-1),await d.readToBuffer(r,0,o*l),await p.endReadSection(d,!0);let y=await k.multiExpAffine(r,q,j,i+"_"+a+"_transformed");return!!k.eq(u,y)||(j&&j.error("Phase2 caclutation does not match with powers of tau"),!1)}}}async function aL(a,b,c,d,e,f,g,h,i,j){let k=e[f],l=2*k.F.n8,m=b[d][0].size/l;await p.startReadUniqueSection(a,b,d),await p.startWriteSection(c,d);let n=g;for(let o=0;o<m;o+=65536){j&&j.debug(`Applying key: ${i}: ${o}/${m}`);let q=Math.min(m-o,65536),r;await c.write(await k.batchApplyKey(await a.read(q*l),n,h)),n=e.Fr.mul(n,e.Fr.exp(h,q))}await p.endWriteSection(c),await p.endReadSection(a)}async function aM(a,b,c,d,e,f,g,h,i,j,k){let l=d[e],m=2*l.F.n8,n=Math.floor(1048576/m),o=g;for(let p=0;p<f;p+=n){k&&k.debug(`Applying key ${j}: ${p}/${f}`);let q=Math.min(f-p,n),r=await a.read(q*m),s=await l.batchUtoLEM(r),t=await l.batchApplyKey(s,o,h),u;u="COMPRESSED"==i?await l.batchLEMtoC(t):await l.batchLEMtoU(t),c&&c.update(u),await b.write(u),o=d.Fr.mul(o,d.Fr.exp(h,q))}}async function aN(a,b,c,d,e){await q.default.ready();let f=await s.readExisting(b),g=16*a.F1.n64,h=16*a.F2.n64,i=(f.totalSize+g-64-h)/(4*g+h),j=i,k=0;for(;j>1;)j/=2,k+=1;if(2**k!=i)throw Error("Invalid file size");e&&e.debug("Power to tau size: "+k);let l=await F(d),m=await s.createOverride(c),n=q.default(64);for(let o=0;o<f.totalSize;o+=f.pageSize){e&&e.debug(`Hashing challenge ${o}/${f.totalSize}`);let p=Math.min(f.totalSize-o,f.pageSize),r=await f.read(p);n.update(r)}let t=await f.read(64,0);e&&e.info(A(t,"Claimed Previous Response Hash: "));let u=n.digest();e&&e.info(A(u,"Current Challenge Hash: "));let v=as(a,u,l);e&&["tau","alpha","beta"].forEach(b=>{e.debug(b+".g1_s: "+a.G1.toString(v[b].g1_s,16)),e.debug(b+".g1_sx: "+a.G1.toString(v[b].g1_sx,16)),e.debug(b+".g2_sp: "+a.G2.toString(v[b].g2_sp,16)),e.debug(b+".g2_spx: "+a.G2.toString(v[b].g2_spx,16)),e.debug("")});let w=q.default(64);await m.write(u),w.update(u),await aM(f,m,w,a,"G1",2**k*2-1,a.Fr.one,v.tau.prvKey,"COMPRESSED","tauG1",e),await aM(f,m,w,a,"G2",2**k,a.Fr.one,v.tau.prvKey,"COMPRESSED","tauG2",e),await aM(f,m,w,a,"G1",2**k,v.alpha.prvKey,v.tau.prvKey,"COMPRESSED","alphaTauG1",e),await aM(f,m,w,a,"G1",2**k,v.beta.prvKey,v.tau.prvKey,"COMPRESSED","betaTauG1",e),await aM(f,m,w,a,"G2",1,v.beta.prvKey,v.tau.prvKey,"COMPRESSED","betaTauG2",e);let x=new Uint8Array(12*a.F1.n8+6*a.F2.n8);ax(x,0,a,v,!1),await m.write(x),w.update(x);let y=w.digest();e&&e.info(A(y,"Contribution Response Hash: ")),await m.close(),await f.close()}async function aO(a,b,c,d,e,f){let g=H(d);if(0==g.byteLength||2*g.byteLength!=d.length)return f&&f.error("Invalid Beacon Hash. (It must be a valid hexadecimal sequence)"),!1;if(g.length>=256)return f&&f.error("Maximum lenght of beacon hash is 255 bytes"),!1;if((e=parseInt(e))<10||e>63)return f&&f.error("Invalid numIterationsExp. (Must be between 10 and 63)"),!1;await q.default.ready();let{fd:h,sections:i}=await p.readBinFile(a,"ptau",1),{curve:j,power:k,ceremonyPower:l}=await au(h,i);if(k!=l)return f&&f.error("This file has been reduced. You cannot contribute into a reduced file."),!1;i[12]&&f&&f.warn("Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.");let m=await aA(h,j,i),n={name:c,type:1,numIterationsExp:e,beaconHash:g},o;o=m.length>0?m[m.length-1].nextChallenge:aD(j,k,f),n.key=aE(j,o,g,e);let r=new q.default(64);r.update(o);let s=await p.createBinFile(b,"ptau",1,7);await at(s,j,k);let t=[],u;u=await y(2,"G1",2**k*2-1,j.Fr.e(1),n.key.tau.prvKey,"tauG1",f),n.tauG1=u[1],u=await y(3,"G2",2**k,j.Fr.e(1),n.key.tau.prvKey,"tauG2",f),n.tauG2=u[1],u=await y(4,"G1",2**k,n.key.alpha.prvKey,n.key.tau.prvKey,"alphaTauG1",f),n.alphaG1=u[0],u=await y(5,"G1",2**k,n.key.beta.prvKey,n.key.tau.prvKey,"betaTauG1",f),n.betaG1=u[0],u=await y(6,"G2",1,n.key.beta.prvKey,n.key.tau.prvKey,"betaTauG2",f),n.betaG2=u[0],n.partialHash=r.getPartialHash();let v=new Uint8Array(12*j.F1.n8+6*j.F2.n8);ax(v,0,j,n.key,!1),r.update(new Uint8Array(v));let w=r.digest();f&&f.info(A(w,"Contribution Response Hash imported: "));let x=new q.default(64);return x.update(w),await z(s,"G1",2,2**k*2-1,"tauG1",f),await z(s,"G2",3,2**k,"tauG2",f),await z(s,"G1",4,2**k,"alphaTauG1",f),await z(s,"G1",5,2**k,"betaTauG1",f),await z(s,"G2",6,1,"betaG2",f),n.nextChallenge=x.digest(),f&&f.info(A(n.nextChallenge,"Next Challenge Hash: ")),m.push(n),await aC(s,j,m),await h.close(),await s.close(),w;async function y(a,b,c,d,e,f,g){let k=[];h.pos=i[a][0].p,await p.startWriteSection(s,a),t[a]=s.pos;let l=j[b],m=2*l.F.n8,n=Math.floor(1048576/m),o=d;for(let q=0;q<c;q+=n){g&&g.debug(`applying key${f}: ${q}/${c}`);let u=Math.min(c-q,n),v=await h.read(u*m),w=await l.batchApplyKey(v,o,e),x=s.write(w),y=await l.batchLEMtoC(w);if(r.update(y),await x,0==q)for(let z=0;z<Math.min(2,c);z++)k.push(l.fromRprLEM(w,z*m));o=j.Fr.mul(o,j.Fr.exp(e,u))}return await p.endWriteSection(s),k}async function z(a,b,c,d,e,f){let g=j[b],h=2*g.F.n8,i=Math.floor(16777216/h),k=a.pos;a.pos=t[c];for(let l=0;l<d;l+=i){f&&f.debug(`Hashing ${e}: ${l}/${d}`);let m=Math.min(d-l,i),n=await a.read(m*h),o=await g.batchLEMtoU(n);x.update(o)}a.pos=k}}async function aP(a,b,c,d,e){await q.default.ready();let{fd:f,sections:g}=await p.readBinFile(a,"ptau",1),{curve:h,power:i,ceremonyPower:j}=await au(f,g);if(i!=j)throw e&&e.error("This file has been reduced. You cannot contribute into a reduced file."),Error("This file has been reduced. You cannot contribute into a reduced file.");g[12]&&e&&e.warn("WARNING: Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.");let k=await aA(f,h,g),l={name:c,type:0},m,n=await F(d);m=k.length>0?k[k.length-1].nextChallenge:aD(h,i,e),l.key=as(h,m,n);let o=new q.default(64);o.update(m);let r=await p.createBinFile(b,"ptau",1,7);await at(r,h,i);let s=[],t;t=await x(2,"G1",2**i*2-1,h.Fr.e(1),l.key.tau.prvKey,"tauG1"),l.tauG1=t[1],t=await x(3,"G2",2**i,h.Fr.e(1),l.key.tau.prvKey,"tauG2"),l.tauG2=t[1],t=await x(4,"G1",2**i,l.key.alpha.prvKey,l.key.tau.prvKey,"alphaTauG1"),l.alphaG1=t[0],t=await x(5,"G1",2**i,l.key.beta.prvKey,l.key.tau.prvKey,"betaTauG1"),l.betaG1=t[0],t=await x(6,"G2",1,l.key.beta.prvKey,l.key.tau.prvKey,"betaTauG2"),l.betaG2=t[0],l.partialHash=o.getPartialHash();let u=new Uint8Array(12*h.F1.n8+6*h.F2.n8);ax(u,0,h,l.key,!1),o.update(new Uint8Array(u));let v=o.digest();e&&e.info(A(v,"Contribution Response Hash imported: "));let w=new q.default(64);return w.update(v),await y(r,"G1",2,2**i*2-1,"tauG1"),await y(r,"G2",3,2**i,"tauG2"),await y(r,"G1",4,2**i,"alphaTauG1"),await y(r,"G1",5,2**i,"betaTauG1"),await y(r,"G2",6,1,"betaG2"),l.nextChallenge=w.digest(),e&&e.info(A(l.nextChallenge,"Next Challenge Hash: ")),k.push(l),await aC(r,h,k),await f.close(),await r.close(),v;async function x(a,b,c,d,i,j){let k=[];f.pos=g[a][0].p,await p.startWriteSection(r,a),s[a]=r.pos;let l=h[b],m=2*l.F.n8,n=Math.floor(1048576/m),q=d;for(let t=0;t<c;t+=n){e&&e.debug(`processing: ${j}: ${t}/${c}`);let u=Math.min(c-t,n),v=await f.read(u*m),w=await l.batchApplyKey(v,q,i),x=r.write(w),y=await l.batchLEMtoC(w);if(o.update(y),await x,0==t)for(let z=0;z<Math.min(2,c);z++)k.push(l.fromRprLEM(w,z*m));q=h.Fr.mul(q,h.Fr.exp(i,u))}return await p.endWriteSection(r),k}async function y(a,b,c,d,f){let g=h[b],i=2*g.F.n8,j=Math.floor(16777216/i),k=a.pos;a.pos=s[c];for(let l=0;l<d;l+=j){e&&l&&e.debug(`Hashing ${f}: `+l);let m=Math.min(d-l,j),n=await a.read(m*i),o=await g.batchLEMtoU(n);w.update(o)}a.pos=k}}async function aQ(a,b,c){let{fd:d,sections:e}=await p.readBinFile(a,"ptau",1),{curve:g,power:h}=await au(d,e),i=await p.createBinFile(b,"ptau",1,11);async function j(a,b,j,k){c&&c.debug("Starting section: "+k),await p.startWriteSection(i,b);for(let l=0;l<=h;l++)await m(l);async function m(b){let l=2**b,m=g[j];g.Fr;let n=2*m.F.n8;m.F.n8;let o;o=new f.BigBuffer(l*n),await p.startReadUniqueSection(d,e,a),2==a&&b==h+1?(await d.readToBuffer(o,0,(l-1)*n),o.set(g.G1.zeroAffine,(l-1)*n)):await d.readToBuffer(o,0,l*n),await p.endReadSection(d,!0),await i.write(o=await m.lagrangeEvaluations(o,"affine","affine",c,k))}2==a&&await m(h+1),await p.endWriteSection(i)}await at(i,g,h),await p.copySection(d,e,i,2),await p.copySection(d,e,i,3),await p.copySection(d,e,i,4),await p.copySection(d,e,i,5),await p.copySection(d,e,i,6),await p.copySection(d,e,i,7),await j(2,12,"G1","tauG1"),await j(3,13,"G2","tauG2"),await j(4,14,"G1","alphaTauG1"),await j(5,15,"G1","betaTauG1"),await d.close(),await i.close()}async function aR(a,b,c){let{fd:d,sections:e}=await p.readBinFile(a,"ptau",1),{curve:f,power:g,ceremonyPower:h}=await au(d,e),i=2*f.G1.F.n8,j=2*f.G2.F.n8;for(let k=1;k<g;k++)await l(k);return await d.close(),!0;async function l(a){let g=a.toString();for(;g.length<2;)g="0"+g;c&&c.debug("Writing Power: "+g);let k=await p.createBinFile(b+g+".ptau","ptau",1,11);await at(k,f,a,h),await p.copySection(d,e,k,2,(2**a*2-1)*i),await p.copySection(d,e,k,3,2**a*j),await p.copySection(d,e,k,4,2**a*i),await p.copySection(d,e,k,5,2**a*i),await p.copySection(d,e,k,6,j),await p.copySection(d,e,k,7),await p.copySection(d,e,k,12,(2**(a+1)*2-1)*i),await p.copySection(d,e,k,13,(2**a*2-1)*j),await p.copySection(d,e,k,14,(2**a*2-1)*i),await p.copySection(d,e,k,15,(2**a*2-1)*i),await k.close()}}async function aS(a,b,c){let{fd:d,sections:e}=await p.readBinFile(a,"ptau",1),{curve:g,power:h}=await au(d,e),i=await p.createBinFile(b,"ptau",1,11);async function j(a,b,j,k){c&&c.debug("Starting section: "+k),await p.startWriteSection(i,b);let l=e[b][0].size,m=d.pageSize;await p.startReadUniqueSection(d,e,b);for(let n=0;n<l;n+=m){let o=Math.min(l-n,m),q=await d.read(o);await i.write(q)}async function r(b){let l=2**b,m=g[j],n=2*m.F.n8,o;o=new f.BigBuffer(l*n),await p.startReadUniqueSection(d,e,a),2==a&&b==h+1?(await d.readToBuffer(o,0,(l-1)*n),o.set(g.G1.zeroAffine,(l-1)*n)):await d.readToBuffer(o,0,l*n),await p.endReadSection(d,!0),await i.write(o=await m.lagrangeEvaluations(o,"affine","affine",c,k))}await p.endReadSection(d),2==a&&await r(h+1),await p.endWriteSection(i)}await at(i,g,h),await p.copySection(d,e,i,2),await p.copySection(d,e,i,3),await p.copySection(d,e,i,4),await p.copySection(d,e,i,5),await p.copySection(d,e,i,6),await p.copySection(d,e,i,7),await j(2,12,"G1","tauG1"),await p.copySection(d,e,i,13),await p.copySection(d,e,i,14),await p.copySection(d,e,i,15),await d.close(),await i.close()}async function aT(a,b){let{fd:c,sections:d}=await p.readBinFile(a,"ptau",1),{curve:e,power:f}=await au(c,d),g={};return g.q=e.q,g.power=f,g.contributions=await aA(c,e,d),g.tauG1=await h(2,"G1",2**f*2-1,"tauG1"),g.tauG2=await h(3,"G2",2**f,"tauG2"),g.alphaTauG1=await h(4,"G1",2**f,"alphaTauG1"),g.betaTauG1=await h(5,"G1",2**f,"betaTauG1"),g.betaG2=await h(6,"G2",1,"betaG2"),g.lTauG1=await i(12,"G1","lTauG1"),g.lTauG2=await i(13,"G2","lTauG2"),g.lAlphaTauG1=await i(14,"G1","lAlphaTauG2"),g.lBetaTauG1=await i(15,"G1","lBetaTauG2"),await c.close(),J(e.Fr,g);async function h(a,f,g,h){let i=e[f],j=2*i.F.n8,k=[];await p.startReadUniqueSection(c,d,a);for(let l=0;l<g;l++){b&&l&&l%1e4==0&&console.log(`${h}: `+l);let m=await c.read(j);k.push(i.fromRprLEM(m,0))}return await p.endReadSection(c),k}async function i(a,g,h){let i=e[g],j=2*i.F.n8,k=[];await p.startReadUniqueSection(c,d,a);for(let l=0;l<=f;l++){b&&console.log(`${h}: Power: ${l}`),k[l]=[];let m=2**l;for(let n=0;n<m;n++){b&&n&&n%1e4==0&&console.log(`${h}: ${n}/${m}`);let o=await c.read(j);k[l].push(i.fromRprLEM(o,0))}}return await p.endReadSection(c,!0),k}}let aU=f.Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),aV=f.Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");async function aW(a,b){let c=await k.readR1cs(a);return f.Scalar.eq(c.prime,aV)?b&&b.info("Curve: bn-128"):f.Scalar.eq(c.prime,aU)?b&&b.info("Curve: bls12-381"):b&&b.info(`Unknown Curve. Prime: ${f.Scalar.toString(c.prime)}`),b&&b.info(`# of Wires: ${c.nVars}`),b&&b.info(`# of Constraints: ${c.nConstraints}`),b&&b.info(`# of Private Inputs: ${c.nPrvInputs}`),b&&b.info(`# of Public Inputs: ${c.nPubInputs}`),b&&b.info(`# of Labels: ${c.nLabels}`),b&&b.info(`# of Outputs: ${c.nOutputs}`),c}async function aX(a,b){let c=await k.readR1cs(a,!0,!0,!0,b),d=c.curve.Fr;return delete c.curve,delete c.F,J(d,c)}async function aY(a){let b={labelIdx2Name:["one"],varIdx2Name:["one"],componentIdx2Name:[]},c=await s.readExisting(a),d=await c.read(c.totalSize),e=new TextDecoder("utf-8").decode(d),f=e.split("\n");for(let g=0;g<f.length;g++){let h=f[g].split(",");4!=h.length||(b.varIdx2Name[h[1]]?b.varIdx2Name[h[1]]+="|"+h[3]:b.varIdx2Name[h[1]]=h[3],b.labelIdx2Name[h[0]]=h[3],b.componentIdx2Name[h[2]]||(b.componentIdx2Name[h[2]]=i(h[3])))}return await c.close(),b;function i(a){let b=a.split(".");return b.pop(),b.join(".")}}let{unstringifyBigInts:aZ}=f.utils;async function a$(a,b,c,d,e,f){let g=aZ(a),h=await s.readExisting(b),i=await h.read(h.totalSize);await h.close();let k={sanityCheck:!0},l=await aY(d);e.set&&(l||(l=await aY(d)),k.logSetSignal=function(a,b){f&&f.info("SET "+l.labelIdx2Name[a]+" <-- "+b.toString())}),e.get&&(l||(l=await aY(d)),k.logGetSignal=function(a,b){f&&f.info("GET "+l.labelIdx2Name[a]+" --> "+b.toString())}),e.trigger&&(l||(l=await aY(d)),k.logStartComponent=function(a){f&&f.info("START: "+l.componentIdx2Name[a])},k.logFinishComponent=function(a){f&&f.info("FINISH: "+l.componentIdx2Name[a])}),k.sym=l;let m=await j.WitnessCalculatorBuilder(i,k),n=await m.calculateWitness(g),o=await p.createBinFile(c,"wtns",2,2);await Z(o,n,m.prime),await o.close()}async function a_(a){let b=await aa(a);return b}class a0{constructor(a){let b=new class{constructor(a){this.length=a||0,this.arr=Array(262144);for(let b=0;b<a;b+=262144)this.arr[b/262144]=Array(Math.min(262144,a-b));return this}push(){for(let a=0;a<arguments.length;a++)this.setElement(this.length,arguments[a])}slice(a,b){let c=Array(b-a);for(let d=a;d<b;d++)c[d-a]=this.getElement(d);return c}getElement(a){a=parseInt(a);let b=Math.floor(a/262144),c=a%262144;return this.arr[b]?this.arr[b][c]:void 0}setElement(a,b){a=parseInt(a);let c=Math.floor(a/262144);this.arr[c]||(this.arr[c]=Array(262144));let d=a%262144;return this.arr[c][d]=b,a>=this.length&&(this.length=a+1),!0}getKeys(){let a=new a0;for(let b=0;b<this.arr.length;b++)if(this.arr[b])for(let c=0;c<this.arr[b].length;c++)void 0!==this.arr[b][c]&&a.push(262144*b+c);return a}}(a),c=new Proxy(b,{get:function(a,b){return isNaN(b)?a[b]:a.getElement(b)},set:function(a,b,c){return isNaN(b)?(a[b]=c,!0):a.setElement(b,c)}});return c}}async function a1(a,b,c,d){await q.default.ready();let g=q.default(64),{fd:h,sections:i}=await e.readBinFile(b,"ptau",1,4194304,16777216),{curve:j,power:l}=await au(h,i),{fd:m,sections:n}=await e.readBinFile(a,"r1cs",1,4194304,16777216),o=await k.readR1csHeader(m,n,!1),p=await e.createBinFile(c,"zkey",1,10,4194304,16777216),r=2*j.G1.F.n8,s=2*j.G2.F.n8;if(o.prime!=j.r)return d&&d.error("r1cs curve does not match powers of tau ceremony curve"),-1;let t=z(o.nConstraints+o.nPubInputs+o.nOutputs+1-1)+1;if(t>l)return d&&d.error(`circuit too big for this power of tau ceremony. ${o.nConstraints}*2 > 2**${l}`),-1;if(!i[12])return d&&d.error("Powers of tau is not prepared."),-1;let u=o.nOutputs+o.nPubInputs,v=2**t;await e.startWriteSection(p,1),await p.writeULE32(1),await e.endWriteSection(p),await e.startWriteSection(p,2);let w=j.q,x=(Math.floor((f.Scalar.bitLength(w)-1)/64)+1)*8,y=j.r,B=(Math.floor((f.Scalar.bitLength(y)-1)/64)+1)*8,C=f.Scalar.mod(f.Scalar.shl(1,8*B),y),D=j.Fr.e(f.Scalar.mod(f.Scalar.mul(C,C),y));await p.writeULE32(x),await e.writeBigInt(p,w,x),await p.writeULE32(B),await e.writeBigInt(p,y,B),await p.writeULE32(o.nVars),await p.writeULE32(u),await p.writeULE32(v);let E;await p.write(E=await h.read(r,i[4][0].p)),E=await j.G1.batchLEMtoU(E),g.update(E);let F;await p.write(F=await h.read(r,i[5][0].p)),F=await j.G1.batchLEMtoU(F),g.update(F);let G;await p.write(G=await h.read(s,i[6][0].p)),G=await j.G2.batchLEMtoU(G),g.update(G);let H=new Uint8Array(r);j.G1.toRprLEM(H,0,j.G1.g);let I=new Uint8Array(s);j.G2.toRprLEM(I,0,j.G2.g);let J=new Uint8Array(r);j.G1.toRprUncompressed(J,0,j.G1.g);let K=new Uint8Array(s);j.G2.toRprUncompressed(K,0,j.G2.g),await p.write(I),await p.write(H),await p.write(I),g.update(K),g.update(J),g.update(K),await e.endWriteSection(p),d&&d.info("Reading r1cs");let L=await e.readSection(m,n,2),M=new a0(o.nVars),N=new a0(o.nVars),O=new a0(o.nVars),P=new a0(o.nVars-u-1),Q=Array(u+1);d&&d.info("Reading tauG1");let R=await e.readSection(h,i,12,(v-1)*r,v*r);d&&d.info("Reading tauG2");let S=await e.readSection(h,i,13,(v-1)*s,v*s);d&&d.info("Reading alphatauG1");let T=await e.readSection(h,i,14,(v-1)*r,v*r);d&&d.info("Reading betatauG1");let U=await e.readSection(h,i,15,(v-1)*r,v*r);await X(),await Y(3,"G1",Q,"IC"),await W(),await $(),await Y(8,"G1",P,"C"),await Y(5,"G1",M,"A"),await Y(6,"G1",N,"B1"),await Y(7,"G2",O,"B2");let V=g.digest();return await e.startWriteSection(p,10),await p.write(V),await p.writeULE32(0),await e.endWriteSection(p),d&&d.info(A(V,"Circuit hash: ")),await p.close(),await m.close(),await h.close(),V;async function W(){await e.startWriteSection(p,9);let a=new f.BigBuffer(v*r);if(t<j.Fr.s){let b=await e.readSection(h,i,12,(2*v-1)*r,2*v*r);for(let c=0;c<v;c++){d&&c%1e4==0&&d.debug(`spliting buffer: ${c}/${v}`);let g=b.slice((2*c+1)*r,(2*c+1)*r+r);a.set(g,c*r)}}else if(t==j.Fr.s){let k=i[12][0].p+(2**(t+1)-1)*r;await h.readToBuffer(a,0,v*r,k+v*r)}else throw d&&d.error("Circuit too big"),Error("Circuit too big for this curve");await p.write(a),await e.endWriteSection(p)}async function X(){let a=new Uint8Array(12+j.Fr.n8),b=new DataView(a.buffer),c=new Uint8Array(j.Fr.n8);j.Fr.toRprLE(c,0,j.Fr.e(1));let g=0;function h(){let a=L.slice(g,g+4);g+=4;let b=new DataView(a.buffer);return b.getUint32(0,!0)}let i=new a0;for(let k=0;k<o.nConstraints;k++){d&&k%1e4==0&&d.debug(`processing constraints: ${k}/${o.nConstraints}`);let l=h();for(let m=0;m<l;m++){let n=h(),q=g;g+=j.Fr.n8;let t=0,v=r*k,w=3,x=r*k;void 0===M[n]&&(M[n]=[]),M[n].push([t,v,q]),n<=u?(void 0===Q[n]&&(Q[n]=[]),Q[n].push([w,x,q])):(void 0===P[n-u-1]&&(P[n-u-1]=[]),P[n-u-1].push([w,x,q])),i.push([0,k,n,q])}let y=h();for(let z=0;z<y;z++){let A=h(),B=g;g+=j.Fr.n8;let C=0,E=r*k,F=1,G=s*k,H=2,I=r*k;void 0===N[A]&&(N[A]=[]),N[A].push([C,E,B]),void 0===O[A]&&(O[A]=[]),O[A].push([F,G,B]),A<=u?(void 0===Q[A]&&(Q[A]=[]),Q[A].push([H,I,B])):(void 0===P[A-u-1]&&(P[A-u-1]=[]),P[A-u-1].push([H,I,B])),i.push([1,k,A,B])}let J=h();for(let K=0;K<J;K++){let R=h(),S=g;g+=j.Fr.n8;let T=0,U=r*k;R<=u?(void 0===Q[R]&&(Q[R]=[]),Q[R].push([T,U,S])):(void 0===P[R-u-1]&&(P[R-u-1]=[]),P[R-u-1].push([T,U,S]))}}for(let V=0;V<=u;V++){let W=0,X=r*(o.nConstraints+V),Y=3,Z=r*(o.nConstraints+V);void 0===M[V]&&(M[V]=[]),M[V].push([W,X,-1]),void 0===Q[V]&&(Q[V]=[]),Q[V].push([Y,Z,-1]),i.push([0,o.nConstraints+V,V,-1])}await e.startWriteSection(p,4);let $=new f.BigBuffer(i.length*(12+j.Fr.n8)+4),_=new Uint8Array(4),aa=new DataView(_.buffer);aa.setUint32(0,i.length,!0),$.set(_);let ab=4;for(let ac=0;ac<i.length;ac++)d&&ac%1e5==0&&d.debug(`writing coeffs: ${ac}/${i.length}`),ad(i[ac]);function ad(d){b.setUint32(0,d[0],!0),b.setUint32(4,d[1],!0),b.setUint32(8,d[2],!0);let e;e=d[3]>=0?j.Fr.fromRprLE(L.slice(d[3],d[3]+j.Fr.n8),0):j.Fr.fromRprLE(c,0);let f=j.Fr.mul(e,D);j.Fr.toRprLE(a,12,f),$.set(a,ab),ab+=a.length}await p.write($),await e.endWriteSection(p)}async function Y(a,b,c,f){let h=j[b];ab(c.length),await e.startWriteSection(p,a);let i=[],k=0;for(;k<c.length;){let l=0;for(;k<c.length&&l<j.tm.concurrency;){d&&d.debug(`Writing points start ${f}: ${k}/${c.length}`);let m=1,n=c[k]?c[k].length:0;for(;k+m<c.length&&n+(c[k+m]?c[k+m].length:0)<32768&&m<32768;)n+=c[k+m]?c[k+m].length:0,m++;let o=c.slice(k,k+m),q=k;i.push(Z(b,o,d,f).then(a=>(d&&d.debug(`Writing points end ${f}: ${q}/${c.length}`),a))),k+=m,l++}let r=await Promise.all(i);for(let s=0;s<r.length;s++){await p.write(r[s][0]);let t=await h.batchLEMtoU(r[s][0]);g.update(t)}i=[]}await e.endWriteSection(p)}async function Z(a,b,c,d){let e=j[a],g=2*e.F.n8,h=3*e.F.n8,i=2*e.F.n8,k,l,m,n;if("G1"==a)k="g1m_timesScalarAffine",l="g1m_multiexpAffine",m="g1m_batchToAffine",n="g1m_zero";else if("G2"==a)k="g2m_timesScalarAffine",l="g2m_multiexpAffine",m="g2m_batchToAffine",n="g2m_zero";else throw Error("Invalid group");let o=0;for(let p=0;p<b.length;p++)o+=b[p]?b[p].length:0;let q,r;o>32768?(q=new f.BigBuffer(o*g),r=new f.BigBuffer(o*j.Fr.n8)):(q=new Uint8Array(o*g),r=new Uint8Array(o*j.Fr.n8));let s=0,t=0,u=[R,S,T,U],v=new Uint8Array(j.Fr.n8);j.Fr.toRprLE(v,0,j.Fr.e(1));let w=0;for(let x=0;x<b.length;x++)if(b[x])for(let y=0;y<b[x].length;y++)c&&y&&y%1e4==0&&c.debug(`Configuring big array ${d}: ${y}/${b[x].length}`),q.set(u[b[x][y][0]].slice(b[x][y][1],b[x][y][1]+g),w*g),b[x][y][2]>=0?r.set(L.slice(b[x][y][2],b[x][y][2]+j.Fr.n8),w*j.Fr.n8):r.set(v,w*j.Fr.n8),w++;if(b.length>1){let z=[];z.push({cmd:"ALLOCSET",var:0,buff:q}),z.push({cmd:"ALLOCSET",var:1,buff:r}),z.push({cmd:"ALLOC",var:2,len:b.length*h}),s=0,t=0;let A=0;for(let B=0;B<b.length;B++){if(!b[B]){z.push({cmd:"CALL",fnName:n,params:[{var:2,offset:A}]}),A+=h;continue}1==b[B].length?z.push({cmd:"CALL",fnName:k,params:[{var:0,offset:s},{var:1,offset:t},{val:j.Fr.n8},{var:2,offset:A}]}):z.push({cmd:"CALL",fnName:l,params:[{var:0,offset:s},{var:1,offset:t},{val:j.Fr.n8},{val:b[B].length},{var:2,offset:A}]}),s+=g*b[B].length,t+=j.Fr.n8*b[B].length,A+=h}z.push({cmd:"CALL",fnName:m,params:[{var:2},{val:b.length},{var:2},]}),z.push({cmd:"GET",out:0,var:2,len:b.length*i});let C=await j.tm.queueAction(z);return C}{let D=await e.multiExpAffine(q,r,c,d);return[e.toAffine(D)]}}async function $(){ab(v-1);for(let a=0;a<v-1;a+=16384){d&&d.debug(`HashingHPoints: ${a}/${v}`);let b=Math.min(v-1,16384);await _(a,b)}}async function _(a,b){let c=await h.read(b*r,i[2][0].p+(a+v)*r),d=await h.read(b*r,i[2][0].p+a*r),e=j.tm.concurrency,f=Math.floor(b/e),k=[];for(let l=0;l<e;l++){let m;if(0==(m=l<e-1?f:b-l*f))continue;let n=c.slice(l*f*r,(l*f+m)*r),o=d.slice(l*f*r,(l*f+m)*r);k.push(aa(n,o))}let p=await Promise.all(k);for(let q=0;q<p.length;q++)g.update(p[q][0])}async function aa(a,b){let c=a.byteLength/r,d=3*j.G1.F.n8,e=[];e.push({cmd:"ALLOCSET",var:0,buff:a}),e.push({cmd:"ALLOCSET",var:1,buff:b}),e.push({cmd:"ALLOC",var:2,len:c*d});for(let f=0;f<c;f++)e.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:f*r},{var:1,offset:f*r},{var:2,offset:f*d},]});e.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:c},{var:2},]}),e.push({cmd:"CALL",fnName:"g1m_batchLEMtoU",params:[{var:2},{val:c},{var:2},]}),e.push({cmd:"GET",out:0,var:2,len:c*r});let g=await j.tm.queueAction(e);return g}function ab(a){let b=new Uint8Array(4),c=new DataView(b.buffer,b.byteOffset,b.byteLength);c.setUint32(0,a,!1),g.update(b)}}async function a2(a,b,c){let{fd:d,sections:e}=await p.readBinFile(a,"zkey",2),f=await P(d,e);if("groth16"!=f.protocol)throw Error("zkey file is not groth16");let g=await x(f.q),h=2*g.G1.F.n8,i=2*g.G2.F.n8,j=await U(d,g,e),k=await s.createOverride(b);await w(f.vk_alpha_1),await w(f.vk_beta_1),await y(f.vk_beta_2),await y(f.vk_gamma_2),await w(f.vk_delta_1),await y(f.vk_delta_2);let l;await z("G1",await g.G1.batchLEMtoU(await p.readSection(d,e,3)));let m=await p.readSection(d,e,9),n;n=await g.G1.fft(m,"affine","jacobian",c),n=await g.G1.batchApplyKey(n,g.Fr.neg(g.Fr.e(2)),g.Fr.w[f.power+1],"jacobian","affine",c),n=n.slice(0,n.byteLength-h),n=await g.G1.batchLEMtoU(n),await z("G1",n);let o;await z("G1",o=await g.G1.batchLEMtoU(o=await p.readSection(d,e,8)));let q;await z("G1",q=await g.G1.batchLEMtoU(q=await p.readSection(d,e,5)));let r;await z("G1",r=await g.G1.batchLEMtoU(r=await p.readSection(d,e,6)));let t;await z("G2",t=await g.G2.batchLEMtoU(t=await p.readSection(d,e,7))),await k.write(j.csHash),await A(j.contributions.length);for(let u=0;u<j.contributions.length;u++){let v=j.contributions[u];await w(v.deltaAfter),await w(v.delta.g1_s),await w(v.delta.g1_sx),await y(v.delta.g2_spx),await k.write(v.transcript)}async function w(a){let b=new Uint8Array(h);g.G1.toRprUncompressed(b,0,a),await k.write(b)}async function y(a){let b=new Uint8Array(i);g.G2.toRprUncompressed(b,0,a),await k.write(b)}async function z(a,b){let c;c="G1"==a?h:i;let d=new Uint8Array(4),e=new DataView(d.buffer,d.byteOffset,d.byteLength);e.setUint32(0,b.byteLength/c,!1),await k.write(d),await k.write(b)}async function A(a){let b=new Uint8Array(4),c=new DataView(b.buffer,b.byteOffset,b.byteLength);c.setUint32(0,a,!1),await k.write(b)}await d.close(),await k.close()}async function a3(a,b,c,d,e){let{fd:f,sections:g}=await p.readBinFile(a,"zkey",2),h=await P(f,g,!1);if("groth16"!=h.protocol)throw Error("zkey file is not groth16");let i=await x(h.q),j=2*i.G1.F.n8,k=2*i.G2.F.n8,l=await U(f,i,g),m={},n=await s.readExisting(b);n.pos=3*j+3*k+8+j*h.nVars+4+j*(h.domainSize-1)+4+j*h.nVars+4+j*h.nVars+4+k*h.nVars,m.csHash=await n.read(64);let o=await n.readUBE32();m.contributions=[];for(let q=0;q<o;q++){let r={delta:{}};r.deltaAfter=await L(n),r.delta.g1_s=await L(n),r.delta.g1_sx=await L(n),r.delta.g2_spx=await M(n),r.transcript=await n.read(64),q<l.contributions.length&&(r.type=l.contributions[q].type,1==r.type&&(r.beaconHash=l.contributions[q].beaconHash,r.numIterationsExp=l.contributions[q].numIterationsExp),l.contributions[q].name&&(r.name=l.contributions[q].name)),m.contributions.push(r)}if(!B(m.csHash,l.csHash))return e&&e.error("Hash of the original circuit does not match with the MPC one"),!1;if(l.contributions.length>m.contributions.length)return e&&e.error("The impoerted file does not include new contributions"),!1;for(let t=0;t<l.contributions.length;t++)if(!N(l.contributions[t],m.contributions[t]))return e&&e.error(`Previos contribution ${t} does not match`),!1;if(d)for(let u=l.contributions.length;u<m.contributions.length;u++)m.contributions[u].name=d;let v=await p.createBinFile(c,"zkey",1,10);n.pos=0,n.pos+=j,n.pos+=j,n.pos+=k,n.pos+=k,h.vk_delta_1=await L(n),h.vk_delta_2=await M(n),await K(v,h);let w=await n.readUBE32();if(w!=h.nPublic+1)return e&&e.error("Invalid number of points in IC"),await v.discard(),!1;n.pos+=j*(h.nPublic+1),await p.copySection(f,g,v,3),await p.copySection(f,g,v,4);let y=await n.readUBE32();if(y!=h.domainSize-1)return e&&e.error("Invalid number of points in H"),await v.discard(),!1;let z,A=await n.read(j*(h.domainSize-1)),C=await i.G1.batchUtoLEM(A);(z=new Uint8Array(h.domainSize*j)).set(C),i.G1.toRprLEM(z,j*(h.domainSize-1),i.G1.zeroAffine);let D=i.Fr.neg(i.Fr.inv(i.Fr.e(2))),E=i.Fr.inv(i.Fr.w[h.power+1]);z=await i.G1.batchApplyKey(z,D,E,"affine","jacobian",e),z=await i.G1.ifft(z,"jacobian","affine",e),await p.startWriteSection(v,9),await v.write(z),await p.endWriteSection(v);let F=await n.readUBE32();if(F!=h.nVars-h.nPublic-1)return e&&e.error("Invalid number of points in L"),await v.discard(),!1;let G;G=await i.G1.batchUtoLEM(G=await n.read(j*(h.nVars-h.nPublic-1))),await p.startWriteSection(v,8),await v.write(G),await p.endWriteSection(v);let H=await n.readUBE32();if(H!=h.nVars)return e&&e.error("Invalid number of points in A"),await v.discard(),!1;n.pos+=j*h.nVars,await p.copySection(f,g,v,5);let I=await n.readUBE32();if(I!=h.nVars)return e&&e.error("Invalid number of points in B1"),await v.discard(),!1;n.pos+=j*h.nVars,await p.copySection(f,g,v,6);let J=await n.readUBE32();if(J!=h.nVars)return e&&e.error("Invalid number of points in B2"),await v.discard(),!1;return n.pos+=k*h.nVars,await p.copySection(f,g,v,7),await W(v,i,m),await n.close(),await v.close(),await f.close(),!0;async function L(a){let b=await a.read(2*i.G1.F.n8);return i.G1.fromRprUncompressed(b,0)}async function M(a){let b=await a.read(2*i.G2.F.n8);return i.G2.fromRprUncompressed(b,0)}function N(a,b){return!!(i.G1.eq(a.deltaAfter,b.deltaAfter)&&i.G1.eq(a.delta.g1_s,b.delta.g1_s)&&i.G1.eq(a.delta.g1_sx,b.delta.g1_sx)&&i.G2.eq(a.delta.g2_spx,b.delta.g2_spx)&&B(a.transcript,b.transcript))}}let a4=D;async function a5(a,b,c,d){let e;await q.default.ready();let{fd:g,sections:h}=await p.readBinFile(c,"zkey",2),i=await P(g,h,!1);if("groth16"!=i.protocol)throw Error("zkey file is not groth16");let j=await x(i.q),k=2*j.G1.F.n8,l=await U(g,j,h),m=q.default(64);m.update(l.csHash);let n=j.G1.g;for(let o=0;o<l.contributions.length;o++){let s=l.contributions[o],t=C(m);if(X(t,j,s.delta.g1_s),X(t,j,s.delta.g1_sx),!B(t.digest(),s.transcript))return console.log(`INVALID(${o}): Inconsistent transcript `),!1;let u=ap(j,s.transcript);if(!0!==(e=await a4(j,s.delta.g1_s,s.delta.g1_sx,u,s.delta.g2_spx)))return console.log(`INVALID(${o}): public key G1 and G2 do not have the same ration `),!1;if(!0!==(e=await a4(j,n,s.deltaAfter,u,s.delta.g2_spx)))return console.log(`INVALID(${o}): deltaAfter does not fillow the public key `),!1;if(1==s.type){let v=G(s.beaconHash,s.numIterationsExp),w=j.Fr.fromRng(v),y=j.G1.toAffine(j.G1.fromRng(v)),z=j.G1.toAffine(j.G1.timesFr(y,w));if(!0!==j.G1.eq(y,s.delta.g1_s))return console.log(`INVALID(${o}): Key of the beacon does not match. g1_s `),!1;if(!0!==j.G1.eq(z,s.delta.g1_sx))return console.log(`INVALID(${o}): Key of the beacon does not match. g1_sx `),!1}Y(m,j,s);let D=q.default(64);Y(D,j,s),s.contributionHash=D.digest(),n=s.deltaAfter}let{fd:E,sections:F}=await p.readBinFile(a,"zkey",2),H=await P(E,F,!1);if("groth16"!=H.protocol)throw Error("zkeyinit file is not groth16");if(!f.Scalar.eq(H.q,i.q)||!f.Scalar.eq(H.r,i.r)||H.n8q!=i.n8q||H.n8r!=i.n8r)return d&&d.error("INVALID:  Different curves"),!1;if(H.nVars!=i.nVars||H.nPublic!=i.nPublic||H.domainSize!=i.domainSize)return d&&d.error("INVALID:  Different circuit parameters"),!1;if(!j.G1.eq(i.vk_alpha_1,H.vk_alpha_1))return d&&d.error("INVALID:  Invalid alpha1"),!1;if(!j.G1.eq(i.vk_beta_1,H.vk_beta_1))return d&&d.error("INVALID:  Invalid beta1"),!1;if(!j.G2.eq(i.vk_beta_2,H.vk_beta_2))return d&&d.error("INVALID:  Invalid beta2"),!1;if(!j.G2.eq(i.vk_gamma_2,H.vk_gamma_2))return d&&d.error("INVALID:  Invalid gamma2"),!1;if(!j.G1.eq(i.vk_delta_1,n))return d&&d.error("INVALID:  Invalid delta1"),!1;if(!0!==(e=await a4(j,j.G1.g,n,j.G2.g,i.vk_delta_2)))return d&&d.error("INVALID:  Invalid delta2"),!1;let J=await U(E,j,F);if(!B(l.csHash,J.csHash))return d&&d.error("INVALID:  Circuit does not match"),!1;if(h[8][0].size!=k*(i.nVars-i.nPublic-1))return d&&d.error("INVALID:  Invalid L section size"),!1;if(h[9][0].size!=k*i.domainSize)return d&&d.error("INVALID:  Invalid H section size"),!1;let K;if(!await p.sectionIsEqual(g,h,E,F,3))return d&&d.error("INVALID:  IC section is not identical"),!1;if(!await p.sectionIsEqual(g,h,E,F,4))return d&&d.error("Coeffs section is not identical"),!1;if(!await p.sectionIsEqual(g,h,E,F,5))return d&&d.error("A section is not identical"),!1;if(!await p.sectionIsEqual(g,h,E,F,6))return d&&d.error("B1 section is not identical"),!1;if(!await p.sectionIsEqual(g,h,E,F,7))return d&&d.error("B2 section is not identical"),!1;if(!0!==(e=await N("G1",E,F,g,h,8,i.vk_delta_2,H.vk_delta_2,"L section")))return d&&d.error("L section does not match"),!1;if(!0!==(e=await O()))return d&&d.error("H section does not match"),!1;d&&d.info(A(l.csHash,"Circuit Hash: ")),await g.close(),await E.close();for(let L=l.contributions.length-1;L>=0;L--){let M=l.contributions[L];d&&d.info("-------------------------"),d&&d.info(A(M.contributionHash,`contribution #${L+1} ${M.name?M.name:""}:`)),1==M.type&&(d&&d.info(`Beacon generator: ${I(M.beaconHash)}`),d&&d.info(`Beacon iterations Exp: ${M.numIterationsExp}`))}return d&&d.info("-------------------------"),d&&d.info("ZKey Ok!"),!0;async function N(a,b,c,f,g,h,i,k,l){let m=j[a],n=2*m.F.n8;await p.startReadUniqueSection(b,c,h),await p.startReadUniqueSection(f,g,h);let o=m.zero,q=m.zero,s=c[h][0].size/n;for(let t=0;t<s;t+=1048576){d&&d.debug(`Same ratio check ${l}:  ${t}/${s}`);let u=Math.min(s-t,1048576),v=await b.read(u*n),w=await f.read(u*n),x=new Uint8Array(4*u);r.default.randomFillSync(x);let y=await m.multiExpAffine(v,x),z=await m.multiExpAffine(w,x);o=m.add(o,y),q=m.add(q,z)}return await p.endReadSection(b),await p.endReadSection(f),0==s|| !0===(e=await a4(j,o,q,i,k))}async function O(){let a=1048576,c=j.G1,k=j.Fr,l=2*c.F.n8,{fd:m,sections:n}=await p.readBinFile(b,"ptau",1),o=new f.BigBuffer(i.domainSize*i.n8r),q=Array(8);for(let s=0;s<8;s++)q[s]=r.default.randomBytes(4).readUInt32BE(0,!0);let t=new f.ChaCha(q);for(let u=0;u<i.domainSize-1;u++){let v=k.fromRng(t);k.toRprLE(o,u*i.n8r,v)}k.toRprLE(o,(i.domainSize-1)*i.n8r,k.zero);let w=c.zero;for(let x=0;x<i.domainSize;x+=a){d&&d.debug(`H Verificaition(tau):  ${x}/${i.domainSize}`);let y=Math.min(i.domainSize-x,a),z=await m.read(l*y,n[2][0].p+i.domainSize*l+x*l),A=await m.read(l*y,n[2][0].p+x*l),B=await Q(z,A),C=o.slice(x*i.n8r,(x+y)*i.n8r),D=await c.multiExpAffine(B,C);w=c.add(w,D)}o=await k.batchToMontgomery(o);let E;if(i.power<k.s)E=k.neg(k.e(2));else{let F=2**k.s,G=k.exp(k.shift,F);E=k.sub(G,k.one)}let I=i.power<k.s?k.w[i.power+1]:k.shift;o=await k.batchApplyKey(o,E,I),o=await k.fft(o),o=await k.batchFromMontgomery(o),await p.startReadUniqueSection(g,h,9);let J=c.zero;for(let K=0;K<i.domainSize;K+=a){d&&d.debug(`H Verificaition(lagrange):  ${K}/${i.domainSize}`);let L=Math.min(i.domainSize-K,a),M=await g.read(l*L),N=o.slice(K*i.n8r,(K+L)*i.n8r),O=await c.multiExpAffine(M,N);J=c.add(J,O)}return await p.endReadSection(g),!0===(e=await a4(j,w,J,i.vk_delta_2,H.vk_delta_2))}async function Q(a,b){let c=2*j.G1.F.n8,d=a.byteLength/c,e=j.tm.concurrency,f=Math.floor(d/e),g=[];for(let h=0;h<e;h++){let i;if(0==(i=h<e-1?f:d-h*f))continue;let l=a.slice(h*f*k,(h*f+i)*k),m=b.slice(h*f*k,(h*f+i)*k);g.push(R(l,m))}let n=await Promise.all(g),o=new Uint8Array(d*c),p=0;for(let q=0;q<n.length;q++)o.set(n[q][0],p),p+=n[q][0].byteLength;return o}async function R(a,b){let c=2*j.G1.F.n8,d=3*j.G1.F.n8,e=a.byteLength/c,f=[];f.push({cmd:"ALLOCSET",var:0,buff:a}),f.push({cmd:"ALLOCSET",var:1,buff:b}),f.push({cmd:"ALLOC",var:2,len:e*d});for(let g=0;g<e;g++)f.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:g*c},{var:1,offset:g*c},{var:2,offset:g*d},]});f.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:e},{var:2},]}),f.push({cmd:"GET",out:0,var:2,len:e*c});let h=await j.tm.queueAction(f);return h}}async function a6(a,b,c,d){let e={type:"bigMem"};return await a1(a,b,e,d),await a5(e,b,c,d)}async function a7(a,b,c,d,e){await q.default.ready();let{fd:f,sections:g}=await p.readBinFile(a,"zkey",2),h=await P(f,g);if("groth16"!=h.protocol)throw Error("zkey file is not groth16");let i=await x(h.q),j=await U(f,i,g),k=await p.createBinFile(b,"zkey",1,10),l=await F(d),m=q.default(64);m.update(j.csHash);for(let n=0;n<j.contributions.length;n++)Y(m,i,j.contributions[n]);let o={};o.delta={},o.delta.prvKey=i.Fr.fromRng(l),o.delta.g1_s=i.G1.toAffine(i.G1.fromRng(l)),o.delta.g1_sx=i.G1.toAffine(i.G1.timesFr(o.delta.g1_s,o.delta.prvKey)),X(m,i,o.delta.g1_s),X(m,i,o.delta.g1_sx),o.transcript=m.digest(),o.delta.g2_sp=ap(i,o.transcript),o.delta.g2_spx=i.G2.toAffine(i.G2.timesFr(o.delta.g2_sp,o.delta.prvKey)),h.vk_delta_1=i.G1.timesFr(h.vk_delta_1,o.delta.prvKey),h.vk_delta_2=i.G2.timesFr(h.vk_delta_2,o.delta.prvKey),o.deltaAfter=h.vk_delta_1,o.type=0,c&&(o.name=c),j.contributions.push(o),await K(k,h),await p.copySection(f,g,k,3),await p.copySection(f,g,k,4),await p.copySection(f,g,k,5),await p.copySection(f,g,k,6),await p.copySection(f,g,k,7);let r=i.Fr.inv(o.delta.prvKey);await aL(f,g,k,8,i,"G1",r,i.Fr.e(1),"L Section",e),await aL(f,g,k,9,i,"G1",r,i.Fr.e(1),"H Section",e),await W(k,i,j),await f.close(),await k.close();let s=q.default(64);Y(s,i,o);let t=s.digest();return e&&e.info(A(j.csHash,"Circuit Hash: ")),e&&e.info(A(t,"Contribution Hash: ")),t}async function a8(a,b,c,d,e,f){await q.default.ready();let g=H(d);if(0==g.byteLength||2*g.byteLength!=d.length)return f&&f.error("Invalid Beacon Hash. (It must be a valid hexadecimal sequence)"),!1;if(g.length>=256)return f&&f.error("Maximum lenght of beacon hash is 255 bytes"),!1;if((e=parseInt(e))<10||e>63)return f&&f.error("Invalid numIterationsExp. (Must be between 10 and 63)"),!1;let{fd:h,sections:i}=await p.readBinFile(a,"zkey",2),j=await P(h,i);if("groth16"!=j.protocol)throw Error("zkey file is not groth16");let k=await x(j.q),l=await U(h,k,i),m=await p.createBinFile(b,"zkey",1,10),n=await G(g,e),o=q.default(64);o.update(l.csHash);for(let r=0;r<l.contributions.length;r++)Y(o,k,l.contributions[r]);let s={};s.delta={},s.delta.prvKey=k.Fr.fromRng(n),s.delta.g1_s=k.G1.toAffine(k.G1.fromRng(n)),s.delta.g1_sx=k.G1.toAffine(k.G1.timesFr(s.delta.g1_s,s.delta.prvKey)),X(o,k,s.delta.g1_s),X(o,k,s.delta.g1_sx),s.transcript=o.digest(),s.delta.g2_sp=ap(k,s.transcript),s.delta.g2_spx=k.G2.toAffine(k.G2.timesFr(s.delta.g2_sp,s.delta.prvKey)),j.vk_delta_1=k.G1.timesFr(j.vk_delta_1,s.delta.prvKey),j.vk_delta_2=k.G2.timesFr(j.vk_delta_2,s.delta.prvKey),s.deltaAfter=j.vk_delta_1,s.type=1,s.numIterationsExp=e,s.beaconHash=g,c&&(s.name=c),l.contributions.push(s),await K(m,j),await p.copySection(h,i,m,3),await p.copySection(h,i,m,4),await p.copySection(h,i,m,5),await p.copySection(h,i,m,6),await p.copySection(h,i,m,7);let t=k.Fr.inv(s.delta.prvKey);await aL(h,i,m,8,k,"G1",t,k.Fr.e(1),"L Section",f),await aL(h,i,m,9,k,"G1",t,k.Fr.e(1),"H Section",f),await W(m,k,l),await h.close(),await m.close();let u=q.default(64);Y(u,k,s);let v=u.digest();return f&&f.info(A(v,"Contribution Hash: ")),v}async function a9(a){let b=await S(a,!0);return delete b.curve,delete b.F,f.utils.stringifyBigInts(b)}async function ba(a,b,c,d,e){await q.default.ready();let f=await F(d),g=a.Fr.fromRng(f),h=a.Fr.inv(g),i=2*a.G1.F.n8,j=2*a.G2.F.n8,k=await s.readExisting(b),l=await s.createOverride(c);await K(i),await K(i),await K(j),await K(j);let m=await L(),n=a.G1.timesFr(m,g);await N(n);let o=await M(),p=a.G2.timesFr(o,g);await O(p);let r=await k.readUBE32();await l.writeUBE32(r),await K(r*i);let t=await k.readUBE32();await l.writeUBE32(t),await aM(k,l,null,a,"G1",t,h,a.Fr.e(1),"UNCOMPRESSED","H",e);let u=await k.readUBE32();await l.writeUBE32(u),await aM(k,l,null,a,"G1",u,h,a.Fr.e(1),"UNCOMPRESSED","L",e);let v=await k.readUBE32();await l.writeUBE32(v),await K(v*i);let w=await k.readUBE32();await l.writeUBE32(w),await K(w*i);let x=await k.readUBE32();await l.writeUBE32(x),await K(x*j);let y=q.default(64),z={};z.csHash=await k.read(64),y.update(z.csHash);let B=await k.readUBE32();z.contributions=[];for(let C=0;C<B;C++){let D={delta:{}};D.deltaAfter=await L(),D.delta.g1_s=await L(),D.delta.g1_sx=await L(),D.delta.g2_spx=await M(),D.transcript=await k.read(64),z.contributions.push(D),Y(y,a,D)}let E={};E.delta={},E.delta.prvKey=g,E.delta.g1_s=a.G1.toAffine(a.G1.fromRng(f)),E.delta.g1_sx=a.G1.toAffine(a.G1.timesFr(E.delta.g1_s,g)),X(y,a,E.delta.g1_s),X(y,a,E.delta.g1_sx),E.transcript=y.digest(),E.delta.g2_sp=ap(a,E.transcript),E.delta.g2_spx=a.G2.toAffine(a.G2.timesFr(E.delta.g2_sp,g)),E.deltaAfter=n,E.type=0,z.contributions.push(E),await l.write(z.csHash),await l.writeUBE32(z.contributions.length);for(let G=0;G<z.contributions.length;G++){let H=z.contributions[G];await N(H.deltaAfter),await N(H.delta.g1_s),await N(H.delta.g1_sx),await O(H.delta.g2_spx),await l.write(H.transcript)}let I=q.default(64);Y(I,a,E);let J=I.digest();return e&&e.info(A(J,"Contribution Hash: ")),await l.close(),await k.close(),J;async function K(a){let b=2*k.pageSize;for(let c=0;c<a;c+=b){let d=Math.min(a-c,b),e=await k.read(d);await l.write(e)}}async function L(){let b=await k.read(2*a.G1.F.n8);return a.G1.fromRprUncompressed(b,0)}async function M(){let b=await k.read(2*a.G2.F.n8);return a.G2.fromRprUncompressed(b,0)}async function N(b){let c=new Uint8Array(i);a.G1.toRprUncompressed(c,0,b),await l.write(c)}async function O(b){let c=new Uint8Array(j);a.G2.toRprUncompressed(c,0,b),await l.write(c)}}let{stringifyBigInts:bb}=f.utils;async function bc(a){let{fd:b,sections:c}=await p.readBinFile(a,"zkey",2),d=await P(b,c),e;if("groth16"==d.protocol)e=await bd(d,b,c);else if("plonk"==d.protocol)e=await be(d);else throw Error("zkey file is not groth16");return await b.close(),e}async function bd(a,b,c){let d=await x(a.q),e=2*d.G1.F.n8,f=await d.pairing(a.vk_alpha_1,a.vk_beta_2),g={protocol:a.protocol,curve:d.name,nPublic:a.nPublic,vk_alpha_1:d.G1.toObject(a.vk_alpha_1),vk_beta_2:d.G2.toObject(a.vk_beta_2),vk_gamma_2:d.G2.toObject(a.vk_gamma_2),vk_delta_2:d.G2.toObject(a.vk_delta_2),vk_alphabeta_12:d.Gt.toObject(f)};await p.startReadUniqueSection(b,c,3),g.IC=[];for(let h=0;h<=a.nPublic;h++){let i=await b.read(e),j=d.G1.toObject(i);g.IC.push(j)}return await p.endReadSection(b),g=bb(g)}async function be(a){let b=await x(a.q),c={protocol:a.protocol,curve:b.name,nPublic:a.nPublic,power:a.power,k1:b.Fr.toObject(a.k1),k2:b.Fr.toObject(a.k2),Qm:b.G1.toObject(a.Qm),Ql:b.G1.toObject(a.Ql),Qr:b.G1.toObject(a.Qr),Qo:b.G1.toObject(a.Qo),Qc:b.G1.toObject(a.Qc),S1:b.G1.toObject(a.S1),S2:b.G1.toObject(a.S2),S3:b.G1.toObject(a.S3),X_2:b.G2.toObject(a.X_2),w:b.Fr.toObject(b.Fr.w[a.power])};return bb(c)}async function bf(a,b,c){let d=await bc(a),e=b[d.protocol];return t.default.render(e,d)}async function bg(a,b,c,d){globalThis.gc&&globalThis.gc(),await q.default.ready();let{fd:g,sections:h}=await e.readBinFile(b,"ptau",1,4194304,16777216),{curve:i,power:j}=await au(g,h),{fd:l,sections:m}=await e.readBinFile(a,"r1cs",1,4194304,16777216),n=await k.readR1csHeader(l,m,!1),o=2*i.G1.F.n8,p=i.G1,r=2*i.G2.F.n8,s=i.Fr,t=i.Fr.n8;d&&d.info("Reading r1cs");let u=await e.readSection(l,m,2),v=new a0,w=new a0,x=n.nVars,y=n.nOutputs+n.nPubInputs;await J(),globalThis.gc&&globalThis.gc();let A=await e.createBinFile(c,"zkey",1,14,4194304,16777216);if(n.prime!=i.r)return d&&d.error("r1cs curve does not match powers of tau ceremony curve"),-1;let B=z(v.length-1)+1;B<3&&(B=3);let C=2**B;if(d&&d.info("Plonk constraints: "+v.length),B>j)return d&&d.error(`circuit too big for this power of tau ceremony. ${v.length} > 2**${j}`),-1;if(!h[12])return d&&d.error("Powers of tau is not prepared."),-1;let D=new f.BigBuffer(C*o),E=h[12][0].p+(2**B-1)*o;await g.readToBuffer(D,0,C*o,E);let[F,G]=function(){let a=s.two;for(;c(a,[],B);)s.add(a,s.one);let b=s.add(a,s.one);for(;c(b,[a],B);)s.add(b,s.one);return[a,b];function c(a,b,c){let d=2**c,e=s.one;for(let f=0;f<d;f++){if(s.eq(a,e))return!0;for(let g=0;g<b.length;g++)if(s.eq(a,s.mul(b[g],e)))return!0;e=s.mul(e,s.w[c])}return!1}}(),H={};await N(3,"Additions"),globalThis.gc&&globalThis.gc(),await K(4,0,"Amap"),globalThis.gc&&globalThis.gc(),await K(5,1,"Bmap"),globalThis.gc&&globalThis.gc(),await K(6,2,"Cmap"),globalThis.gc&&globalThis.gc(),await L(7,3,"Qm"),globalThis.gc&&globalThis.gc(),await L(8,4,"Ql"),globalThis.gc&&globalThis.gc(),await L(9,5,"Qr"),globalThis.gc&&globalThis.gc(),await L(10,6,"Qo"),globalThis.gc&&globalThis.gc(),await L(11,7,"Qc"),globalThis.gc&&globalThis.gc(),await O(12,"sigma"),globalThis.gc&&globalThis.gc(),await P(13,"lagrange polynomials"),globalThis.gc&&globalThis.gc(),await e.startWriteSection(A,14);let I=new f.BigBuffer((C+6)*o);async function J(){let a=0;function b(){let b=u.slice(a,a+4);a+=4;let c=new DataView(b.buffer);return c.getUint32(0,!0)}function c(){let b=s.fromRprLE(u.slice(a,a+i.Fr.n8));return a+=i.Fr.n8,b}function e(){let a=[],d={k:i.Fr.zero},e=b();for(let g=0;g<e;g++){let h=b(),j=c();0==h?d.k=j:a.push([h,j])}let k=f(a);return d.s=k[0],d.coef=k[1],d}function f(a){if(0==a.length)return[0,i.Fr.zero];if(1==a.length)return a[0];let b=a.slice(0,a.length>>1),c=a.slice(a.length>>1),d=f(b),e=f(c),g=d[0],h=e[0],j=x++,k=i.Fr.zero,l=s.neg(d[1]),m=s.neg(e[1]),n=i.Fr.one,o=i.Fr.zero;return v.push([g,h,j,k,l,m,n,o]),w.push([g,h,d[1],e[1]]),[j,i.Fr.one]}for(let g=1;g<=y;g++){let h=g,j=0,k=0,l=i.Fr.zero,m=i.Fr.one,o=i.Fr.zero,p=i.Fr.zero,q=i.Fr.zero;v.push([h,j,k,l,m,o,p,q])}for(let r=0;r<n.nConstraints;r++){d&&r%1e4==0&&d.debug(`processing constraints: ${r}/${n.nConstraints}`);let t=e(),z=e(),A=e(),B=t.s,C=z.s,D=A.s,E=i.Fr.mul(t.coef,z.coef),F=i.Fr.mul(t.coef,z.k),G=i.Fr.mul(t.k,z.coef),H=i.Fr.neg(A.coef),I=i.Fr.sub(i.Fr.mul(t.k,z.k),A.k);v.push([B,C,D,E,F,G,H,I])}}async function K(a,b,c){await e.startWriteSection(A,a);for(let f=0;f<v.length;f++)await A.writeULE32(v[f][b]),d&&f%1e6==0&&d.debug(`writing ${c}: ${f}/${v.length}`);await e.endWriteSection(A)}async function L(a,b,c){let g=new f.BigBuffer(C*t);for(let h=0;h<v.length;h++)g.set(v[h][b],h*t),d&&h%1e6==0&&d.debug(`writing ${c}: ${h}/${v.length}`);await e.startWriteSection(A,a),await M(g),await e.endWriteSection(A),g=await s.batchFromMontgomery(g),H[c]=await i.G1.multiExpAffine(D,g,d,"multiexp "+c)}async function M(a){let b=await s.ifft(a),c=new f.BigBuffer(C*t*4);c.set(b,0);let d=await s.fft(c);await A.write(b),await A.write(d)}async function N(a,b){await e.startWriteSection(A,a);let c=new Uint8Array(8+2*t),f=new DataView(c.buffer);for(let g=0;g<w.length;g++){let h=w[g],i=0;f.setUint32(i,h[0],!0),i+=4,f.setUint32(i,h[1],!0),i+=4,c.set(h[2],i),i+=t,c.set(h[3],i),i+=t,await A.write(c),d&&g%1e6==0&&d.debug(`writing ${b}: ${g}/${w.length}`)}await e.endWriteSection(A)}async function O(a,b){let c=new f.BigBuffer(t*C*3),g=new a0(x),h=new a0(x),j=s.one;for(let k=0;k<C;k++)k<v.length?(p(v[k][0],k),p(v[k][1],C+k),p(v[k][2],2*C+k)):(p(0,k),p(0,C+k),p(0,2*C+k)),j=s.mul(j,s.w[B]),d&&k%1e6==0&&d.debug(`writing ${b} phase1: ${k}/${v.length}`);for(let l=0;l<x;l++)void 0!==h[l]?c.set(g[l],h[l]*t):console.log("Variable not used"),d&&l%1e6==0&&d.debug(`writing ${b} phase2: ${l}/${x}`);globalThis.gc&&globalThis.gc(),await e.startWriteSection(A,a);let m=c.slice(0,C*t);await M(m),globalThis.gc&&globalThis.gc();let n=c.slice(C*t,C*t*2);await M(n),globalThis.gc&&globalThis.gc();let o=c.slice(C*t*2,C*t*3);function p(a,b){void 0===g[a]?h[a]=b:c.set(g[a],b*t);let d;d=b<C?j:b<2*C?s.mul(j,F):s.mul(j,G),g[a]=d}await M(o),globalThis.gc&&globalThis.gc(),await e.endWriteSection(A),m=await s.batchFromMontgomery(m),n=await s.batchFromMontgomery(n),o=await s.batchFromMontgomery(o),H.S1=await i.G1.multiExpAffine(D,m,d,"multiexp S1"),globalThis.gc&&globalThis.gc(),H.S2=await i.G1.multiExpAffine(D,n,d,"multiexp S2"),globalThis.gc&&globalThis.gc(),H.S3=await i.G1.multiExpAffine(D,o,d,"multiexp S3"),globalThis.gc&&globalThis.gc()}async function P(a,b){await e.startWriteSection(A,a);let c=Math.max(y,1);for(let g=0;g<c;g++){let h=new f.BigBuffer(C*t);h.set(s.one,g*t),await M(h),d&&d.debug(`writing ${b} ${g}/${c}`)}await e.endWriteSection(A)}async function Q(){await e.startWriteSection(A,1),await A.writeULE32(2),await e.endWriteSection(A),await e.startWriteSection(A,2);let a=i.q,b=(Math.floor((f.Scalar.bitLength(a)-1)/64)+1)*8,c=i.r,d=(Math.floor((f.Scalar.bitLength(c)-1)/64)+1)*8;await A.writeULE32(b),await e.writeBigInt(A,a,b),await A.writeULE32(d),await e.writeBigInt(A,c,d),await A.writeULE32(x),await A.writeULE32(y),await A.writeULE32(C),await A.writeULE32(w.length),await A.writeULE32(v.length),await A.write(F),await A.write(G),await A.write(p.toAffine(H.Qm)),await A.write(p.toAffine(H.Ql)),await A.write(p.toAffine(H.Qr)),await A.write(p.toAffine(H.Qo)),await A.write(p.toAffine(H.Qc)),await A.write(p.toAffine(H.S1)),await A.write(p.toAffine(H.S2)),await A.write(p.toAffine(H.S3));let j;await A.write(await g.read(r,h[3][0].p+r)),await e.endWriteSection(A)}await g.readToBuffer(I,0,(C+6)*o,h[2][0].p),await A.write(I),await e.endWriteSection(A),globalThis.gc&&globalThis.gc(),await Q(),await A.close(),await l.close(),await g.close(),d&&d.info("Setup Finished")}let{stringifyBigInts:bh}=f.utils,{keccak256:bi}=u.default;async function bj(a,b,c){let{fd:d,sections:e}=await p.readBinFile(b,"wtns",2,33554432,8388608),g=await _(d,e),{fd:h,sections:i}=await p.readBinFile(a,"zkey",2,33554432,8388608),j=await P(h,i);if("plonk"!=j.protocol)throw Error("zkey file is not plonk");if(!f.Scalar.eq(j.r,g.q))throw Error("Curve of the witness does not match the curve of the proving key");if(g.nWitness!=j.nVars-j.nAdditions)throw Error(`Invalid witness length. Circuit: ${j.nVars}, witness: ${g.nWitness}, ${j.nAdditions}`);let k=j.curve,l=k.Fr,m=k.G1,n=k.Fr.n8;c&&c.debug("Reading Wtns");let o=await p.readSection(d,e,2);o.set(l.zero,0);let q=new f.BigBuffer(n*j.nAdditions);await Q();let r,s,t,u,v,w,x,y,z,A,B,C,D,E,F={},G=new f.BigBuffer(j.domainSize*n*12),H=i[12][0].p+j.domainSize*n;await h.readToBuffer(G,0,j.domainSize*n*4,H),H+=j.domainSize*n*5,await h.readToBuffer(G,j.domainSize*n*4,j.domainSize*n*4,H),H+=j.domainSize*n*5,await h.readToBuffer(G,j.domainSize*n*8,j.domainSize*n*4,H);let I=new f.BigBuffer(j.domainSize*n);await h.readToBuffer(I,0,j.domainSize*n,i[12][0].p);let J=new f.BigBuffer(j.domainSize*n);await h.readToBuffer(J,0,j.domainSize*n,i[12][0].p+5*j.domainSize*n);let K=await p.readSection(h,i,14),L={};await U(),await V(),await W(),await X(),await Y(),F.protocol="plonk",F.curve=k.name,await h.close(),await d.close();let M=[];for(let N=1;N<=j.nPublic;N++){let O=o.slice(N*l.n8,N*l.n8+l.n8);M.push(f.Scalar.fromRprLE(O))}return F.A=m.toObject(F.A),F.B=m.toObject(F.B),F.C=m.toObject(F.C),F.Z=m.toObject(F.Z),F.T1=m.toObject(F.T1),F.T2=m.toObject(F.T2),F.T3=m.toObject(F.T3),F.eval_a=l.toObject(F.eval_a),F.eval_b=l.toObject(F.eval_b),F.eval_c=l.toObject(F.eval_c),F.eval_s1=l.toObject(F.eval_s1),F.eval_s2=l.toObject(F.eval_s2),F.eval_zw=l.toObject(F.eval_zw),F.eval_t=l.toObject(F.eval_t),F.eval_r=l.toObject(F.eval_r),F.Wxi=m.toObject(F.Wxi),F.Wxiw=m.toObject(F.Wxiw),delete F.eval_t,F=bh(F),M=bh(M),{proof:F,publicSignals:M};async function Q(){let a=await p.readSection(h,i,3),b=8+2*k.Fr.n8;for(let c=0;c<j.nAdditions;c++){let d=S(a,c*b),e=S(a,c*b+4),f=a.slice(c*b+8,c*b+8+n),g=a.slice(c*b+8+n,c*b+8+2*n),l=T(d),m=T(e),o=k.Fr.add(k.Fr.mul(f,l),k.Fr.mul(g,m));q.set(o,n*c)}}async function R(){let a=new f.BigBuffer(j.domainSize*n),b=new f.BigBuffer(j.domainSize*n),c=new f.BigBuffer(j.domainSize*n),d=await p.readSection(h,i,4),e=await p.readSection(h,i,5),g=await p.readSection(h,i,6);for(let k=0;k<j.nConstrains;k++){let m=S(d,4*k);a.set(T(m),k*n);let o=S(e,4*k);b.set(T(o),k*n);let q=S(g,4*k);c.set(T(q),k*n)}return a=await l.batchToMontgomery(a),b=await l.batchToMontgomery(b),c=await l.batchToMontgomery(c),[a,b,c]}function S(a,b){let c=a.slice(b,b+4),d=new DataView(c.buffer,c.byteOffset,c.byteLength);return d.getUint32(0,!0)}function T(a){return a<j.nVars-j.nAdditions?o.slice(a*n,a*n+n):a<j.nVars?q.slice((a-(j.nVars-j.nAdditions))*n,(a-(j.nVars-j.nAdditions))*n+n):k.Fr.zero}async function U(){L.b=[];for(let a=1;a<=9;a++)L.b[a]=k.Fr.random();[r,s,t]=await R(),[z,v]=await ac(r,[L.b[2],L.b[1]]),[A,w]=await ac(s,[L.b[4],L.b[3]]),[B,x]=await ac(t,[L.b[6],L.b[5]]),F.A=await ab(z,"multiexp A"),F.B=await ab(A,"multiexp B"),F.C=await ab(B,"multiexp C")}async function V(){let a=new Uint8Array(j.nPublic*n+6*m.F.n8);for(let b=0;b<j.nPublic;b++)l.toRprBE(a,b*n,r.slice(b*n,(b+1)*n));m.toRprUncompressed(a,j.nPublic*n+0,F.A),m.toRprUncompressed(a,j.nPublic*n+2*m.F.n8,F.B),m.toRprUncompressed(a,j.nPublic*n+4*m.F.n8,F.C),L.beta=Z(a),c&&c.debug("beta: "+l.toString(L.beta));let d=new Uint8Array(n);l.toRprBE(d,0,L.beta),L.gamma=Z(d),c&&c.debug("gamma: "+l.toString(L.gamma));let e=new f.BigBuffer(l.n8*j.domainSize),g=new f.BigBuffer(l.n8*j.domainSize);e.set(l.one,0),g.set(l.one,0);let h=l.one;for(let i=0;i<j.domainSize;i++){let k=r.slice(i*n,(i+1)*n);k=l.add(k,l.mul(L.beta,h)),k=l.add(k,L.gamma);let o=s.slice(i*n,(i+1)*n);o=l.add(o,l.mul(j.k1,l.mul(L.beta,h))),o=l.add(o,L.gamma);let p=t.slice(i*n,(i+1)*n);p=l.add(p,l.mul(j.k2,l.mul(L.beta,h))),p=l.add(p,L.gamma);let q=l.mul(k,l.mul(o,p)),v=r.slice(i*n,(i+1)*n);v=l.add(v,l.mul(G.slice(i*n*4,i*n*4+n),L.beta)),v=l.add(v,L.gamma);let w=s.slice(i*n,(i+1)*n);w=l.add(w,l.mul(G.slice((j.domainSize+i)*4*n,(j.domainSize+i)*4*n+n),L.beta)),w=l.add(w,L.gamma);let x=t.slice(i*n,(i+1)*n);x=l.add(x,l.mul(G.slice((2*j.domainSize+i)*4*n,(2*j.domainSize+i)*4*n+n),L.beta)),x=l.add(x,L.gamma);let z=l.mul(v,l.mul(w,x));e.set(l.mul(e.slice(i*n,(i+1)*n),q),(i+1)%j.domainSize*n),g.set(l.mul(g.slice(i*n,(i+1)*n),z),(i+1)%j.domainSize*n),h=l.mul(h,l.w[j.power])}g=await l.batchInverse(g);for(let A=0;A<j.domainSize;A++)e.set(l.mul(e.slice(A*n,(A+1)*n),g.slice(A*n,(A+1)*n)),A*n);if(!l.eq(e.slice(0,n),l.one))throw Error("Copy constraints does not match");u=e,[C,y]=await ac(u,[L.b[9],L.b[8],L.b[7]]),F.Z=await ab(C,"multiexp Z")}async function W(){c&&c.debug("phse3: Reading QM4");let a=new f.BigBuffer(4*j.domainSize*n);await h.readToBuffer(a,0,j.domainSize*n*4,i[7][0].p+j.domainSize*n),c&&c.debug("phse3: Reading QL4");let b=new f.BigBuffer(4*j.domainSize*n);await h.readToBuffer(b,0,j.domainSize*n*4,i[8][0].p+j.domainSize*n),c&&c.debug("phse3: Reading QR4");let d=new f.BigBuffer(4*j.domainSize*n);await h.readToBuffer(d,0,j.domainSize*n*4,i[9][0].p+j.domainSize*n),c&&c.debug("phse3: Reading QO4");let e=new f.BigBuffer(4*j.domainSize*n);await h.readToBuffer(e,0,j.domainSize*n*4,i[10][0].p+j.domainSize*n),c&&c.debug("phse3: Reading QC4");let g=new f.BigBuffer(4*j.domainSize*n);await h.readToBuffer(g,0,j.domainSize*n*4,i[11][0].p+j.domainSize*n);let k=await p.readSection(h,i,13),o=new Uint8Array(2*m.F.n8);m.toRprUncompressed(o,0,F.Z),L.alpha=Z(o),c&&c.debug("alpha: "+l.toString(L.alpha));let q=[l.zero,l.add(l.e(-1),l.w[2]),l.e(-2),l.sub(l.e(-1),l.w[2]),],s=[l.zero,l.add(l.zero,l.mul(l.e(-2),l.w[2])),l.e(4),l.sub(l.zero,l.mul(l.e(-2),l.w[2])),],t=[l.zero,l.add(l.e(2),l.mul(l.e(2),l.w[2])),l.e(-8),l.sub(l.e(2),l.mul(l.e(2),l.w[2])),],u=new f.BigBuffer(4*j.domainSize*n),z=new f.BigBuffer(4*j.domainSize*n),A=l.one;for(let B=0;B<4*j.domainSize;B++){B%4096==0&&c&&c.debug(`calculating t ${B}/${4*j.domainSize}`);let C=v.slice(B*n,B*n+n),E=w.slice(B*n,B*n+n),H=x.slice(B*n,B*n+n),I=y.slice(B*n,B*n+n),J=y.slice((B+4*j.domainSize+4)%(4*j.domainSize)*n,(B+4*j.domainSize+4)%(4*j.domainSize)*n+n),K=a.slice(B*n,B*n+n),M=b.slice(B*n,B*n+n),N=d.slice(B*n,B*n+n),O=e.slice(B*n,B*n+n),P=g.slice(B*n,B*n+n),Q=G.slice(B*n,B*n+n),R=G.slice((B+4*j.domainSize)*n,(B+4*j.domainSize)*n+n),S=G.slice((B+8*j.domainSize)*n,(B+8*j.domainSize)*n+n),T=l.add(L.b[2],l.mul(L.b[1],A)),U=l.add(L.b[4],l.mul(L.b[3],A)),V=l.add(L.b[6],l.mul(L.b[5],A)),W=l.square(A),X=l.add(l.add(l.mul(L.b[7],W),l.mul(L.b[8],A)),L.b[9]),Y=l.mul(A,l.w[j.power]),$=l.square(Y),_=l.add(l.add(l.mul(L.b[7],$),l.mul(L.b[8],Y)),L.b[9]),aa=l.zero;for(let ac=0;ac<j.nPublic;ac++)aa=l.sub(aa,l.mul(k.slice((5*ac*j.domainSize+j.domainSize+B)*n,(5*ac*j.domainSize+j.domainSize+B+1)*n),r.slice(ac*n,(ac+1)*n)));let[ad,ae]=aD(C,E,T,U,B%4);ad=l.mul(ad,K),ae=l.mul(ae,K),ad=l.add(ad,l.mul(C,M)),ae=l.add(ae,l.mul(T,M)),ad=l.add(ad,l.mul(E,N)),ae=l.add(ae,l.mul(U,N)),ad=l.add(ad,l.mul(H,O)),ae=l.add(ae,l.mul(V,O)),ad=l.add(ad,aa),ad=l.add(ad,P);let af=l.mul(L.beta,A),ag=C;ag=l.add(ag,af),ag=l.add(ag,L.gamma);let ah=E;ah=l.add(ah,l.mul(af,j.k1)),ah=l.add(ah,L.gamma);let ai=H;ai=l.add(ai,l.mul(af,j.k2)),ai=l.add(ai,L.gamma);let aj=I,[ak,al]=aE(ag,ah,ai,aj,T,U,V,X,B%4);ak=l.mul(ak,L.alpha),al=l.mul(al,L.alpha);let am=C;am=l.add(am,l.mul(L.beta,Q)),am=l.add(am,L.gamma);let an=E;an=l.add(an,l.mul(L.beta,R)),an=l.add(an,L.gamma);let ao=H;ao=l.add(ao,l.mul(L.beta,S)),ao=l.add(ao,L.gamma);let ap=J,[aq,ar]=aE(am,an,ao,ap,T,U,V,_,B%4);aq=l.mul(aq,L.alpha),ar=l.mul(ar,L.alpha);let as=l.sub(I,l.one);as=l.mul(as,k.slice((j.domainSize+B)*n,(j.domainSize+B+1)*n)),as=l.mul(as,l.mul(L.alpha,L.alpha));let at=l.mul(X,k.slice((j.domainSize+B)*n,(j.domainSize+B+1)*n));at=l.mul(at,l.mul(L.alpha,L.alpha));let au=l.add(l.sub(l.add(ad,ak),aq),as),av=l.add(l.sub(l.add(ae,al),ar),at);u.set(au,B*n),z.set(av,B*n),A=l.mul(A,l.w[j.power+2])}c&&c.debug("ifft T");let aw=await l.ifft(u);c&&c.debug("dividing T/Z");for(let ax=0;ax<j.domainSize;ax++)aw.set(l.neg(aw.slice(ax*n,ax*n+n)),ax*n);for(let ay=j.domainSize;ay<4*j.domainSize;ay++){let az=l.sub(aw.slice((ay-j.domainSize)*n,(ay-j.domainSize)*n+n),aw.slice(ay*n,ay*n+n));if(aw.set(az,ay*n),ay>3*j.domainSize-4&&!l.isZero(az))throw Error("T Polynomial is not divisible")}c&&c.debug("ifft Tz");let aA=await l.ifft(z);for(let aB=0;aB<4*j.domainSize;aB++){let aC=aA.slice(aB*n,(aB+1)*n);if(aB>3*j.domainSize+5){if(!l.isZero(aC))throw Error("Tz Polynomial is not well calculated")}else aw.set(l.add(aw.slice(aB*n,(aB+1)*n),aC),aB*n)}function aD(a,b,c,d,e){let f,g,h=l.mul(a,b),i=l.mul(a,d),j=l.mul(c,b),k=l.mul(c,d);f=h;let m;return g=l.add(i,j),e&&(g=l.add(g,l.mul(q[e],k))),[f,g]}function aE(a,b,c,d,e,f,g,h,i){let j,k,m=l.mul(a,b),n=l.mul(a,f),o=l.mul(e,b),p=l.mul(e,f),r=l.mul(c,d),u=l.mul(c,h),v=l.mul(g,d),w=l.mul(g,h);j=l.mul(m,r);let x=l.mul(o,r);x=l.add(x,l.mul(n,r)),x=l.add(x,l.mul(m,v)),x=l.add(x,l.mul(m,u));let y=l.mul(p,r);y=l.add(y,l.mul(o,v)),y=l.add(y,l.mul(o,u)),y=l.add(y,l.mul(n,v)),y=l.add(y,l.mul(n,u)),y=l.add(y,l.mul(m,w));let z=l.mul(n,w);z=l.add(z,l.mul(o,w)),z=l.add(z,l.mul(p,u)),z=l.add(z,l.mul(p,v));let A=l.mul(p,w);return k=x,i&&(k=l.add(k,l.mul(q[i],y)),k=l.add(k,l.mul(s[i],z)),k=l.add(k,l.mul(t[i],A))),[j,k]}D=aw.slice(0,(3*j.domainSize+6)*n),F.T1=await ab(aw.slice(0,j.domainSize*n),"multiexp T1"),F.T2=await ab(aw.slice(j.domainSize*n,2*j.domainSize*n),"multiexp T2"),F.T3=await ab(aw.slice(2*j.domainSize*n,(3*j.domainSize+6)*n),"multiexp T3")}async function X(){let a=new f.BigBuffer(j.domainSize*n);await h.readToBuffer(a,0,j.domainSize*n,i[7][0].p);let b=new f.BigBuffer(j.domainSize*n);await h.readToBuffer(b,0,j.domainSize*n,i[8][0].p);let d=new f.BigBuffer(j.domainSize*n);await h.readToBuffer(d,0,j.domainSize*n,i[9][0].p);let e=new f.BigBuffer(j.domainSize*n);await h.readToBuffer(e,0,j.domainSize*n,i[10][0].p);let g=new f.BigBuffer(j.domainSize*n);await h.readToBuffer(g,0,j.domainSize*n,i[11][0].p);let k=new f.BigBuffer(j.domainSize*n);await h.readToBuffer(k,0,j.domainSize*n,i[12][0].p+10*j.domainSize*n);let o=new Uint8Array(6*m.F.n8);m.toRprUncompressed(o,0,F.T1),m.toRprUncompressed(o,2*m.F.n8,F.T2),m.toRprUncompressed(o,4*m.F.n8,F.T3),L.xi=Z(o),c&&c.debug("xi: "+l.toString(L.xi)),F.eval_a=$(z,L.xi),F.eval_b=$(A,L.xi),F.eval_c=$(B,L.xi),F.eval_s1=$(I,L.xi),F.eval_s2=$(J,L.xi),F.eval_t=$(D,L.xi),F.eval_zw=$(C,l.mul(L.xi,l.w[j.power]));let p=l.mul(F.eval_a,F.eval_b),q=F.eval_a,r=l.mul(L.beta,L.xi);q=l.add(q,r),q=l.add(q,L.gamma);let s=F.eval_b;s=l.add(s,l.mul(r,j.k1)),s=l.add(s,L.gamma);let t=F.eval_c;t=l.add(t,l.mul(r,j.k2)),t=l.add(t,L.gamma);let u=l.mul(l.mul(l.mul(q,s),t),L.alpha),v=F.eval_a;v=l.add(v,l.mul(L.beta,F.eval_s1)),v=l.add(v,L.gamma);let w=F.eval_b;w=l.add(w,l.mul(L.beta,F.eval_s2)),w=l.add(w,L.gamma);let x=l.mul(v,w);x=l.mul(x,L.beta),x=l.mul(x,F.eval_zw),x=l.mul(x,L.alpha),L.xim=L.xi;for(let y=0;y<j.power;y++)L.xim=l.mul(L.xim,L.xim);let G=l.div(l.sub(L.xim,l.one),l.mul(l.sub(L.xi,l.one),l.e(j.domainSize))),H=l.mul(G,l.mul(L.alpha,L.alpha)),K=x,M=l.add(u,H);E=new f.BigBuffer((j.domainSize+3)*n);for(let N=0;N<j.domainSize+3;N++){let O=l.mul(M,C.slice(N*n,(N+1)*n));N<j.domainSize&&(O=l.add(O,l.mul(p,a.slice(N*n,(N+1)*n))),O=l.add(O,l.mul(F.eval_a,b.slice(N*n,(N+1)*n))),O=l.add(O,l.mul(F.eval_b,d.slice(N*n,(N+1)*n))),O=l.add(O,l.mul(F.eval_c,e.slice(N*n,(N+1)*n))),O=l.add(O,g.slice(N*n,(N+1)*n)),O=l.sub(O,l.mul(K,k.slice(N*n,(N+1)*n)))),E.set(O,N*n)}F.eval_r=$(E,L.xi)}async function Y(){let a=new Uint8Array(7*n);l.toRprBE(a,0,F.eval_a),l.toRprBE(a,n,F.eval_b),l.toRprBE(a,2*n,F.eval_c),l.toRprBE(a,3*n,F.eval_s1),l.toRprBE(a,4*n,F.eval_s2),l.toRprBE(a,5*n,F.eval_zw),l.toRprBE(a,6*n,F.eval_r),L.v=[],L.v[1]=Z(a),c&&c.debug("v: "+l.toString(L.v[1]));for(let b=2;b<=6;b++)L.v[b]=l.mul(L.v[b-1],L.v[1]);let d=new f.BigBuffer((j.domainSize+6)*n),e=l.mul(L.xim,L.xim);for(let g=0;g<j.domainSize+6;g++){let h=l.zero;h=l.add(h,l.mul(e,D.slice((2*j.domainSize+g)*n,(2*j.domainSize+g+1)*n))),g<j.domainSize+3&&(h=l.add(h,l.mul(L.v[1],E.slice(g*n,(g+1)*n)))),g<j.domainSize+2&&(h=l.add(h,l.mul(L.v[2],z.slice(g*n,(g+1)*n))),h=l.add(h,l.mul(L.v[3],A.slice(g*n,(g+1)*n))),h=l.add(h,l.mul(L.v[4],B.slice(g*n,(g+1)*n)))),g<j.domainSize&&(h=l.add(h,D.slice(g*n,(g+1)*n)),h=l.add(h,l.mul(L.xim,D.slice((j.domainSize+g)*n,(j.domainSize+g+1)*n))),h=l.add(h,l.mul(L.v[5],I.slice(g*n,(g+1)*n))),h=l.add(h,l.mul(L.v[6],J.slice(g*n,(g+1)*n)))),d.set(h,g*n)}let i=d.slice(0,n);i=l.sub(i,F.eval_t),i=l.sub(i,l.mul(L.v[1],F.eval_r)),i=l.sub(i,l.mul(L.v[2],F.eval_a)),i=l.sub(i,l.mul(L.v[3],F.eval_b)),i=l.sub(i,l.mul(L.v[4],F.eval_c)),i=l.sub(i,l.mul(L.v[5],F.eval_s1)),i=l.sub(i,l.mul(L.v[6],F.eval_s2)),d.set(i,0),d=aa(d,L.xi),F.Wxi=await ab(d,"multiexp Wxi");let k=new f.BigBuffer((j.domainSize+3)*n);for(let m=0;m<j.domainSize+3;m++){let o=C.slice(m*n,(m+1)*n);k.set(o,m*n)}i=k.slice(0,n),i=l.sub(i,F.eval_zw),k.set(i,0),k=aa(k,l.mul(L.xi,l.w[j.power])),F.Wxiw=await ab(k,"multiexp Wxiw")}function Z(a){let b=f.Scalar.fromRprBE(new Uint8Array(bi.arrayBuffer(a)));return l.e(b)}function $(a,b){let c=a.byteLength/n;if(0==c)return l.zero;let d=a.slice((c-1)*n,c*n);for(let e=c-2;e>=0;e--)d=l.add(l.mul(d,b),a.slice(e*n,(e+1)*n));return d}function aa(a,b){let c=a.byteLength/n,d=new f.BigBuffer(c*n);d.set(l.zero,(c-1)*n),d.set(a.slice((c-1)*n,c*n),(c-2)*n);for(let e=c-3;e>=0;e--)d.set(l.add(a.slice((e+1)*n,(e+2)*n),l.mul(b,d.slice((e+1)*n,(e+2)*n))),e*n);if(!l.eq(a.slice(0,n),l.mul(l.neg(b),d.slice(0,n))))throw Error("Polinomial does not divide");return d}async function ab(a,b){let d=a.byteLength/n,e=K.slice(0,d*k.G1.F.n8*2),f=await k.Fr.batchFromMontgomery(a),g=await k.G1.multiExpAffine(e,f,c,b);return k.G1.toAffine(g)}async function ac(a,b){b=b||[];let c=await l.ifft(a),d=new f.BigBuffer(n*j.domainSize*4);d.set(c,0);let e=new f.BigBuffer(n*(j.domainSize+b.length));e.set(c,0);for(let g=0;g<b.length;g++)e.set(l.add(e.slice((j.domainSize+g)*n,(j.domainSize+g+1)*n),b[g]),(j.domainSize+g)*n),e.set(l.sub(e.slice(g*n,(g+1)*n),b[g]),g*n);let h=await l.fft(d);return[e,h]}}let{unstringifyBigInts:bk}=f.utils;async function bl(a,b,c,d){let e=bk(a),f={type:"mem"};return await ag(e,b,f),await bj(c,f,d)}let{unstringifyBigInts:bm}=f.utils,{keccak256:bn}=u.default;async function bo(a,b,c,d){let e=bm(a),f=bm(c),g=bm(b),h=await y(e.curve),i=h.Fr,j=h.G1;if(f=bp(h,f),e=bq(h,e),!br(h,f))return d.error("Proof is not well constructed"),!1;if(g.length!=e.nPublic)return d.error("Invalid number of public inputs"),!1;let k=bs(h,f,g);d&&(d.debug("beta: "+i.toString(k.beta,16)),d.debug("gamma: "+i.toString(k.gamma,16)),d.debug("alpha: "+i.toString(k.alpha,16)),d.debug("xi: "+i.toString(k.xi,16)),d.debug("v1: "+i.toString(k.v[1],16)),d.debug("v6: "+i.toString(k.v[6],16)),d.debug("u: "+i.toString(k.u,16)));let l=bt(h,k,e);if(d){d.debug("Lagrange Evaluations: ");for(let m=1;m<l.length;m++)d.debug(`L${m}(xi)=`+i.toString(l[m],16))}if(g.length!=e.nPublic)return d.error("Number of public signals does not match with vk"),!1;let n=bv(h,g,l);d&&d.debug("Pl: "+i.toString(n,16));let o=bw(h,f,k,n,l[1]);d&&d.debug("t: "+i.toString(o,16));let p=bx(h,f,k,e,l[1]);d&&d.debug("D: "+j.toString(j.toAffine(p),16));let q=by(h,f,k,e,p);d&&d.debug("F: "+j.toString(j.toAffine(q),16));let r=bz(h,f,k,e,o);d&&d.debug("E: "+j.toString(j.toAffine(r),16));let s=await bA(h,f,k,e,r,q);return d&&(s?d.info("OK!"):d.warn("Invalid Proof")),s}function bp(a,b){let c=a.G1,d=a.Fr,e={};return e.A=c.fromObject(b.A),e.B=c.fromObject(b.B),e.C=c.fromObject(b.C),e.Z=c.fromObject(b.Z),e.T1=c.fromObject(b.T1),e.T2=c.fromObject(b.T2),e.T3=c.fromObject(b.T3),e.eval_a=d.fromObject(b.eval_a),e.eval_b=d.fromObject(b.eval_b),e.eval_c=d.fromObject(b.eval_c),e.eval_zw=d.fromObject(b.eval_zw),e.eval_s1=d.fromObject(b.eval_s1),e.eval_s2=d.fromObject(b.eval_s2),e.eval_r=d.fromObject(b.eval_r),e.Wxi=c.fromObject(b.Wxi),e.Wxiw=c.fromObject(b.Wxiw),e}function bq(a,b){let c=a.G1,d=a.G2,e=a.Fr,f=b;return f.Qm=c.fromObject(b.Qm),f.Ql=c.fromObject(b.Ql),f.Qr=c.fromObject(b.Qr),f.Qo=c.fromObject(b.Qo),f.Qc=c.fromObject(b.Qc),f.S1=c.fromObject(b.S1),f.S2=c.fromObject(b.S2),f.S3=c.fromObject(b.S3),f.k1=e.fromObject(b.k1),f.k2=e.fromObject(b.k2),f.X_2=d.fromObject(b.X_2),f}function br(a,b){let c=a.G1;return!!(c.isValid(b.A)&&c.isValid(b.B)&&c.isValid(b.C)&&c.isValid(b.Z)&&c.isValid(b.T1)&&c.isValid(b.T2)&&c.isValid(b.T3)&&c.isValid(b.Wxi)&&c.isValid(b.Wxiw))}function bs(a,b,c){let d=a.G1,e=a.Fr,f=a.Fr.n8,g={},h=new Uint8Array(c.length*f+6*d.F.n8);for(let i=0;i<c.length;i++)e.toRprBE(h,i*f,e.e(c[i]));d.toRprUncompressed(h,c.length*f+0,b.A),d.toRprUncompressed(h,c.length*f+2*d.F.n8,b.B),d.toRprUncompressed(h,c.length*f+4*d.F.n8,b.C),g.beta=bu(a,h);let j=new Uint8Array(f);e.toRprBE(j,0,g.beta),g.gamma=bu(a,j);let k=new Uint8Array(2*d.F.n8);d.toRprUncompressed(k,0,b.Z),g.alpha=bu(a,k);let l=new Uint8Array(6*d.F.n8);d.toRprUncompressed(l,0,b.T1),d.toRprUncompressed(l,2*d.F.n8,b.T2),d.toRprUncompressed(l,4*d.F.n8,b.T3),g.xi=bu(a,l);let m=new Uint8Array(7*f);e.toRprBE(m,0,b.eval_a),e.toRprBE(m,f,b.eval_b),e.toRprBE(m,2*f,b.eval_c),e.toRprBE(m,3*f,b.eval_s1),e.toRprBE(m,4*f,b.eval_s2),e.toRprBE(m,5*f,b.eval_zw),e.toRprBE(m,6*f,b.eval_r),g.v=[],g.v[1]=bu(a,m);for(let n=2;n<=6;n++)g.v[n]=e.mul(g.v[n-1],g.v[1]);let o=new Uint8Array(4*d.F.n8);return d.toRprUncompressed(o,0,b.Wxi),d.toRprUncompressed(o,2*d.F.n8,b.Wxiw),g.u=bu(a,o),g}function bt(a,b,c){let d=a.Fr,e=b.xi,f=1;for(let g=0;g<c.power;g++)e=d.square(e),f*=2;b.xin=e,b.zh=d.sub(e,d.one);let h=[],i=d.e(f),j=d.one;for(let k=1;k<=Math.max(1,c.nPublic);k++)h[k]=d.div(d.mul(j,b.zh),d.mul(i,d.sub(b.xi,j))),j=d.mul(j,d.w[c.power]);return h}function bu(a,b){let c=f.Scalar.fromRprBE(new Uint8Array(bn.arrayBuffer(b)));return a.Fr.e(c)}function bv(a,b,c){let d=a.Fr,e=d.zero;for(let f=0;f<b.length;f++){let g=d.e(b[f]);e=d.sub(e,d.mul(g,c[f+1]))}return e}function bw(a,b,c,d,e){let f=a.Fr,g=b.eval_r;g=f.add(g,d);let h=b.eval_a;h=f.add(h,f.mul(c.beta,b.eval_s1)),h=f.add(h,c.gamma);let i=b.eval_b;i=f.add(i,f.mul(c.beta,b.eval_s2)),i=f.add(i,c.gamma);let j=b.eval_c;j=f.add(j,c.gamma);let k=f.mul(f.mul(h,i),j);k=f.mul(k,b.eval_zw),k=f.mul(k,c.alpha),g=f.sub(g,k),g=f.sub(g,f.mul(e,f.square(c.alpha)));let l=f.div(g,c.zh);return l}function bx(a,b,c,d,e){let f=a.G1,g=a.Fr,h=g.mul(g.mul(b.eval_a,b.eval_b),c.v[1]),i=f.timesFr(d.Qm,h),j=g.mul(b.eval_a,c.v[1]);i=f.add(i,f.timesFr(d.Ql,j));let k=g.mul(b.eval_b,c.v[1]);i=f.add(i,f.timesFr(d.Qr,k));let l=g.mul(b.eval_c,c.v[1]);i=f.add(i,f.timesFr(d.Qo,l)),i=f.add(i,f.timesFr(d.Qc,c.v[1]));let m=g.mul(c.beta,c.xi),n=b.eval_a;n=g.add(n,m),n=g.add(n,c.gamma);let o=b.eval_b;o=g.add(o,g.mul(m,d.k1)),o=g.add(o,c.gamma);let p=b.eval_c;p=g.add(p,g.mul(m,d.k2)),p=g.add(p,c.gamma);let q=g.mul(g.mul(n,o),p);q=g.mul(q,g.mul(c.alpha,c.v[1]));let r=g.mul(g.mul(e,g.square(c.alpha)),c.v[1]);q=g.add(q,r),q=g.add(q,c.u),i=f.add(i,f.timesFr(b.Z,q));let s=b.eval_a;s=g.add(s,g.mul(c.beta,b.eval_s1)),s=g.add(s,c.gamma);let t=b.eval_b;t=g.add(t,g.mul(c.beta,b.eval_s2)),t=g.add(t,c.gamma);let u=g.mul(s,t);return u=g.mul(u,c.alpha),u=g.mul(u,c.v[1]),u=g.mul(u,c.beta),u=g.mul(u,b.eval_zw),i=f.sub(i,f.timesFr(d.S3,u))}function by(a,b,c,d,e){let f=a.G1,g=a.Fr,h=b.T1;return h=f.add(h,f.timesFr(b.T2,c.xin)),h=f.add(h,f.timesFr(b.T3,g.square(c.xin))),h=f.add(h,e),h=f.add(h,f.timesFr(b.A,c.v[2])),h=f.add(h,f.timesFr(b.B,c.v[3])),h=f.add(h,f.timesFr(b.C,c.v[4])),h=f.add(h,f.timesFr(d.S1,c.v[5])),h=f.add(h,f.timesFr(d.S2,c.v[6]))}function bz(a,b,c,d,e){let f=a.G1,g=a.Fr,h=e;h=g.add(h,g.mul(c.v[1],b.eval_r)),h=g.add(h,g.mul(c.v[2],b.eval_a)),h=g.add(h,g.mul(c.v[3],b.eval_b)),h=g.add(h,g.mul(c.v[4],b.eval_c)),h=g.add(h,g.mul(c.v[5],b.eval_s1)),h=g.add(h,g.mul(c.v[6],b.eval_s2)),h=g.add(h,g.mul(c.u,b.eval_zw));let i=f.timesFr(f.one,h);return i}async function bA(a,b,c,d,e,f){let g=a.G1,h=a.Fr,i=b.Wxi;i=g.add(i,g.timesFr(b.Wxiw,c.u));let j=g.timesFr(b.Wxi,c.xi),k=h.mul(h.mul(c.u,c.xi),h.w[d.power]);j=g.add(j,g.timesFr(b.Wxiw,k)),j=g.add(j,f),j=g.sub(j,e);let l=await a.pairingEq(g.neg(i),d.X_2,j,a.G2.one);return l}let{unstringifyBigInts:bB}=f.utils;function bC(a){return("0"+a.toString(16)).slice(-2)}function bD(a){let b=a.toString(16);for(;b.length<64;)b="0"+b;return`"0x${b}"`}async function bE(a,b){let c=bB(a),d=bB(b),e=await y(c.curve),f=e.G1,g=e.Fr,h="";for(let i=0;i<d.length;i++)""!=h&&(h+=","),h+=bD(d[i]);let j=new Uint8Array(18*f.F.n8+7*g.n8);f.toRprUncompressed(j,0,f.e(c.A)),f.toRprUncompressed(j,2*f.F.n8,f.e(c.B)),f.toRprUncompressed(j,4*f.F.n8,f.e(c.C)),f.toRprUncompressed(j,6*f.F.n8,f.e(c.Z)),f.toRprUncompressed(j,8*f.F.n8,f.e(c.T1)),f.toRprUncompressed(j,10*f.F.n8,f.e(c.T2)),f.toRprUncompressed(j,12*f.F.n8,f.e(c.T3)),f.toRprUncompressed(j,14*f.F.n8,f.e(c.Wxi)),f.toRprUncompressed(j,16*f.F.n8,f.e(c.Wxiw)),g.toRprBE(j,18*f.F.n8,g.e(c.eval_a)),g.toRprBE(j,18*f.F.n8+g.n8,g.e(c.eval_b)),g.toRprBE(j,18*f.F.n8+2*g.n8,g.e(c.eval_c)),g.toRprBE(j,18*f.F.n8+3*g.n8,g.e(c.eval_s1)),g.toRprBE(j,18*f.F.n8+4*g.n8,g.e(c.eval_s2)),g.toRprBE(j,18*f.F.n8+5*g.n8,g.e(c.eval_zw)),g.toRprBE(j,18*f.F.n8+6*g.n8,g.e(c.eval_r));let k=Array.from(j).map(bC).join(""),l="0x"+k+",["+h+"]";return l}b.tt=ao}}])